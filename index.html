<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elite Invaders 3D</title>
    <!-- Importation de la police Sci-Fi "Orbitron" -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- 
      Conformément au CDC (Section 9.1), nous utilisons une superposition HTML/CSS 
      pour l'interface utilisateur (UI) par-dessus le canvas du jeu.
    -->
    <style>
        body {
            /* Utilisation de la nouvelle police */
            font-family: 'Orbitron', 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            /* Nouveau fond radial pour la profondeur */
            background: radial-gradient(ellipse at center, #1a2a40 0%, #000010 100%);
            color: #00ffff; /* Nouvelle couleur de base "Cyan Neon" */
            overflow: hidden; /* Empêche le défilement */
        }

        /* Conteneur principal qui superpose l'UI et le Canvas */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* Le canvas de rendu 3D */
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Superposition de l'UI (Section 9.1) */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none; 
        }

        /* Menus qui doivent être cliquables */
        .menu {
            /* Effet "Verre Dépoli" moderne */
            background-color: rgba(0, 20, 30, 0.75);
            backdrop-filter: blur(5px);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            pointer-events: auto; /* Réactive les événements pour ce menu */
            /* Ombre "Neon Glow" */
            box-shadow: 0 0 20px #00ffff, inset 0 0 10px #00ffff;
            animation: pulse-glow 2s infinite alternate;
        }
        
        @keyframes pulse-glow {
            from {
                box-shadow: 0 0 20px #00ffff, inset 0 0 10px #00ffff;
            }
            to {
                box-shadow: 0 0 35px #00ffff, inset 0 0 15px #00ffff;
            }
        }

        .menu h1 {
            margin-top: 0;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 3px;
            /* Effet "Neon Glow" pour le texte */
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #00ffff, 0 0 30px #00ffff;
        }
        
        .menu p {
            font-size: 1.2em;
            text-shadow: 0 0 5px #00ffff;
        }

        /* Panneau des scores */
        #leaderboard {
            width: 80%;
            margin: 20px auto;
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid #00bfff;
            border-radius: 5px;
            padding: 10px;
            box-shadow: inset 0 0 10px rgba(0, 191, 255, 0.5);
        }
        #leaderboard h2 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
            color: #fff;
            text-shadow: 0 0 10px #00bfff;
        }
        #high-score-list {
            list-style-type: decimal;
            padding-left: 30px;
            margin: 0;
            text-align: left;
            font-size: 1.1em;
            color: #00ffff;
        }
        #high-score-list li {
            margin-bottom: 5px;
            text-shadow: 0 0 5px #00ffff;
        }

        .menu button {
            background-color: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Orbitron', 'Arial', sans-serif;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s, box-shadow 0.3s, color 0.3s;
            text-shadow: 0 0 10px #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }

        .menu button:hover {
            background-color: #00ffff;
            color: #000;
            box-shadow: 0 0 25px #00ffff, 0 0 40px #fff;
            text-shadow: none;
        }

        /* HUD en jeu (Section 9.1) */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 1.5em;
            color: #00ffff;
            /* Effet "Neon Glow" pour le HUD */
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
            display: none; /* Caché par défaut */
        }

        /* Barre de vie du Boss (CDC 9.3) */
        #boss-health-bar {
            position: absolute;
            top: 80px; /* Sous le HUD principal */
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            height: 20px;
            background-color: rgba(255, 0, 0, 0.1);
            border: 2px solid #f00;
            border-radius: 5px;
            display: none; /* Caché par défaut */
            box-shadow: 0 0 15px #f00;
        }
        #boss-health {
            width: 100%;
            height: 100%;
            background-color: #f00;
            border-radius: 2px;
            transition: width 0.2s ease-out;
            box-shadow: 0 0 10px #f00, 0 0 20px #f00;
        }

        /* Écrans de la FSM Globale (Section 9.2) */
        #main-menu { display: flex; }
        #game-over-screen { display: none; }
        #loading-screen { display: flex; }
        #pause-menu { display: none; } /* AJOUT: État de pause */

    </style>
</head>
<body>

    <!-- 
      Structure HTML (Section 9.1)
      - game-container : Conteneur principal
      - game-canvas : Rendu 3D (Three.js)
      - ui-overlay : Superposition HTML pour l'UI
    -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="ui-overlay">
            
            <!-- État PRELOADING (Section 9.4) -->
            <div id="loading-screen" class="menu">
                <h1>ELITE INVADERS 3D</h1>
                <p id="loading-text">CHARGEMENT DES SYSTÈMES...</p>
            </div>

            <!-- État MAIN_MENU (Section 9.2) -->
            <div id="main-menu" class="menu" style="display: none;">
                <h1>ELITE INVADERS 3D</h1>
                <!-- MODIFIÉ: Panneau des scores (CDC 9.6) -->
                <div id="leaderboard">
                    <h2>MEILLEURS SCORES</h2>
                    <ol id="high-score-list">
                        <li>---</li>
                        <li>---</li>
                        <li>---</li>
                    </ol>
                </div>
                <button id="start-button">COMMENCER LA MISSION</button>
            </div>

            <!-- État GAME_OVER (Section 9.2) -->
            <div id="game-over-screen" class="menu" style="display: none;">
                <h1>MISSION ÉCHOUÉE</h1>
                <p id="final-score">SCORE : 0</p>
                <button id="restart-button">RÉESSAYER</button>
            </div>

            <!-- AJOUT: État PAUSED (CDC 9.2) -->
            <div id="pause-menu" class="menu" style="display: none;">
                <h1>PAUSE</h1>
                <button id="resume-button">REPRENDRE</button>
            </div>

            <!-- HUD (Head-Up Display) (Section 9.1) -->
            <div id="hud">
                <div id="score">SCORE : 0</div>
                <!-- AJOUT: Affichage du niveau -->
                <div id="level">NIVEAU : 1</div>
                <div id="lives">VIES : 3</div>
            </div>

            <!-- AJOUT: Barre de vie du Boss (CDC 9.3) -->
            <div id="boss-health-bar">
                <div id="boss-health"></div>
            </div>

        </div>
    </div>

    <!-- 
      Importation de Three.js.
      Nous utilisons un "importmap" pour gérer les modules JSM
      nécessaires pour le post-traitement (Effet Bloom).
    -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    
        // --- Imports 3D (y compris Post-Traitement) ---
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

        // =====================================================================
        // 1. FONDATIONS TECHNIQUES ET ARCHITECTURE (CDC Sections 2, 3)
        // =====================================================================

        // --- 1.1 Moteurs 3D (Three.js) ---
        let scene, camera, renderer, clock;
        // AJOUT: Compositeur pour le post-traitement (Bloom)
        let composer, bloomPass, filmPass;
        let gameSize = { width: 20, height: 20 }; // Taille de la zone de jeu en unités 3D
        
        // --- 1.2 Boucle de Jeu (Game Loop) (CDC Section 2.2) ---
        let deltaTime = 0;

        // --- 1.3 FSM Globale (Gestionnaire d'état) (CDC Section 9.2) ---
        const GAME_STATE = {
            PRELOADING: 'PRELOADING',
            MAIN_MENU: 'MAIN_MENU',
            PLAYING: 'PLAYING',
            PAUSED: 'PAUSED', // AJOUT: État de pause (CDC 9.2)
            GAME_OVER: 'GAME_OVER'
        };
        let currentGameState = GAME_STATE.PRELOADING;

        // --- 1.4 Architecture ECS (simplifiée) (CDC Section 3) ---
        let entities = [];
        let player = null;
        let alienGrid = {
            aliens: [],
            direction: 1, 
            speed: 0.5,
            baseSpeed: 0.5,
            moveDown: false,
            fireRate: 0.02,
            baseFireRate: 0.02,
            dropChance: 0.2, 
            toughAlienChance: 0.2 
        };
        
        // --- 1.5 Gestion des Entrées (InputSystem) (CDC Section 3.3) ---
        const input = {
            left: false,
            right: false,
            fire: false,
            currentMoveX: 0 
        };

        // --- 1.6 Statistiques de jeu ---
        let score = 0;
        let lives = 55; // MODIFIÉ: 3 -> 55
        let currentLevel = 1; 

        // --- 1.7 Entités de jeu supplémentaires ---
        let shields = [];
        let ufo = null;
        let ufoSpawnTimer = 15.0; 
        let starfield, starfield2; // AJOUT: 2e couche pour parallaxe
        let nebula; // AJOUT: Nébuleuse
        let boss = null; 
        let bossHealthBar, bossHealthElement;

        // =====================================================================
        // 2. AUDIO (CDC Section 8)
        // =====================================================================
        
        // --- 2.1 Web Audio API (CDC Section 8.1) ---
        let audioContext;
        let sfxGain; // GainNode pour les SFX
        let musicGain; // GainNode pour la musique
        const audioBuffers = {}; // Stockage des sons pré-chargés

        class AudioEngine {
            async init() {
                if (audioContext) return; 
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                sfxGain = audioContext.createGain();
                musicGain = audioContext.createGain();
                
                sfxGain.gain.value = 0.7;
                musicGain.gain.value = 0.3;

                sfxGain.connect(audioContext.destination);
                musicGain.connect(audioContext.destination);
            }

            // Pré-chargement (Section 9.4)
            async loadSound(name, url) {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    audioBuffers[name] = audioBuffer;
                } catch (e) {
                    console.error(`Erreur lors du chargement du son ${name}:`, e);
                }
            }

            // Jouer un son (AudioSystem)
            playSound(name, spatialNode = null) {
                if (!audioBuffers[name] || !audioContext) return;
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffers[name];

                if (spatialNode) {
                    source.connect(spatialNode);
                    spatialNode.connect(sfxGain);
                } else {
                    source.connect(sfxGain);
                }
                source.start(0);
            }
            
            // Crée un nœud de spatialisation 3D (PannerNode)
            createSpatialNode() {
                const panner = audioContext.createPanner();
                panner.panningModel = 'HRTF';
                panner.distanceModel = 'inverse';
                panner.refDistance = 1;
                panner.maxDistance = 100;
                panner.rolloffFactor = 1;
                return panner;
            }
        }
        const audioEngine = new AudioEngine();

        // =====================================================================
        // 3. OPTIMISATION : OBJECT POOLING (CDC Section 4.1)
        // =====================================================================
        
        // --- Géométrie et Matériaux partagés (Refonte Visuelle) ---
        
        // Tirs (Lasers)
        const bulletGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
        // MATÉRIAUX ÉMISSIFS pour l'effet Bloom
        const playerBulletMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x00ff00, 
            emissive: 0x00ff00, // Brille
            emissiveIntensity: 5 // AUGMENTÉ (de 2 à 5)
        });
        const alienBulletMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xff0000, 
            emissive: 0xff0000, // Brille
            emissiveIntensity: 5 // AUGMENTÉ (de 2 à 5)
        });
        
        // Particules
        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0], 3));
        const particleMaterial = new THREE.PointsMaterial({ 
            color: 0xffaa00, 
            size: 0.1, 
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false // Important pour le blending
        });
        
        // Boucliers (Nouveau design)
        const shieldGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2.5, 12);
        shieldGeometry.rotateX(Math.PI / 2); // Pivoter horizontalement
        const shieldMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0088ff, 
            transparent: true, 
            opacity: 0.6,
            metalness: 0.8,
            roughness: 0.1,
            emissive: 0x002288,
            emissiveIntensity: 1
        });
        
        // Power-ups (Nouveau design "Cristal")
        const powerUpGeometry = new THREE.TetrahedronGeometry(0.3);
        const powerUpMatRapid = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1, metalness: 0.5, roughness: 0.3 });
        const powerUpMatSpread = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 1, metalness: 0.5, roughness: 0.3 });
        const powerUpMatShield = new THREE.MeshStandardMaterial({ color: 0x0088ff, emissive: 0x0088ff, emissiveIntensity: 1, metalness: 0.5, roughness: 0.3 });
        
        // UFO (Nouveau design "Soucoupe")
        const ufoGeometry = new THREE.TorusGeometry(0.6, 0.2, 8, 16);
        ufoGeometry.rotateX(Math.PI / 2);
        const ufoMaterial = new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xaa0000, metalness: 0.9, roughness: 0.2 });
        
        // Aliens (Nouveau design "Drone")
        const alienGeometry = new THREE.IcosahedronGeometry(0.5, 0); // Cristal
        const alienMatNormal = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0x550055, metalness: 0.8, roughness: 0.3 });
        const alienMatTough = new THREE.MeshStandardMaterial({ color: 0xff8800, emissive: 0x883300, metalness: 0.8, roughness: 0.3 });

        // AJOUT: Lumières pour les tirs (pour le pooling)
        const playerLightPool = [];
        const alienLightPool = [];

        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 50) {
                this.pool = [];
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.expandPool(initialSize);
            }

            expandPool(size) {
                for (let i = 0; i < size; i++) {
                    const obj = this.createFn();
                    obj.active = false;
                    scene.add(obj.mesh); 
                    this.pool.push(obj);
                }
            }

            get() {
                let obj = this.pool.find(o => !o.active);
                if (!obj) {
                    this.expandPool(Math.floor(this.pool.length * 0.5));
                    obj = this.pool.find(o => !o.active);
                }
                
                obj.active = true;
                obj.mesh.visible = true;
                this.resetFn(obj);
                return obj;
            }

            release(obj) {
                obj.active = false;
                obj.mesh.visible = false;
                obj.mesh.position.set(0, -100, 0);
                
                // CORRECTION: Logique de lumière déplacée vers resetBullet
                // et les fonctions de spawn.
                // Juste s'assurer de la retirer de la scène.
                if (obj.light) {
                    obj.light.visible = false;
                    obj.mesh.remove(obj.light); 
                    // Le pool correct (joueur/alien) sera géré
                    // au prochain appel de resetBullet
                }
            }

            getActiveObjects() {
                return this.pool.filter(o => o.active);
            }
        }

        // Définition des pools
        let bulletPool, particlePool, powerUpPool;

        // =====================================================================
        // 4. ENTITÉS ET SYSTÈMES DE JEU (CDC Sections 3, 5, 6, 7)
        // =====================================================================

        // --- 4.1 Fonctions de création (pour les pools) ---

        function createBulletEntity() {
            const mesh = new THREE.Mesh(bulletGeometry, playerBulletMaterial); // CORRECTION: Ajout d'un matériau par défaut
            const audioNode = audioEngine.createSpatialNode();
            
            const entity = {
                mesh: mesh,
                active: false,
                type: 'bullet',
                isPlayerBullet: true,
                velocity: new THREE.Vector3(0, 5, 0),
                lifetime: 2, 
                collider: new THREE.Box3(),
                audioNode: audioNode,
                light: null // AJOUT: Pour la lumière dynamique
            };
            entities.push(entity);
            return entity;
        }
        
        function createParticleEntity() {
            const mesh = new THREE.Points(particleGeometry, particleMaterial.clone());
            const entity = {
                mesh: mesh,
                active: false,
                type: 'particle',
                velocity: new THREE.Vector3(),
                lifetime: 0.5,
                baseSize: 0.1
            };
            entities.push(entity);
            return entity;
        }

        // Ajout : Power-Up (CDC 6.4)
        function createPowerUpEntity() {
            const mesh = new THREE.Mesh(powerUpGeometry, powerUpMatRapid.clone()); 
            const entity = {
                mesh: mesh,
                active: false,
                type: 'powerup',
                velocity: new THREE.Vector3(0, -2, 0), 
                lifetime: 10.0, 
                collider: new THREE.Box3(),
                powerUpType: 'rapid_fire' 
            };
            entities.push(entity);
            return entity;
        }

        // --- 4.2 Fonctions de "Reset" (pour les pools) ---

        function resetBullet(bullet) {
            bullet.lifetime = 2;
            bullet.mesh.rotation.x = Math.PI / 2;
            
            // CORRECTION: Retirer l'ancienne lumière. La nouvelle sera ajoutée par le spawner.
            if (bullet.light) {
                bullet.light.visible = false;
                bullet.mesh.remove(bullet.light); 
                
                // Devine où la remettre en se basant sur la couleur
                // (getHex() peut être lent, mais c'est plus robuste que le flag)
                if (bullet.light.color.getHex() === 0x00ff00) { 
                    playerLightPool.push(bullet.light);
                } else {
                    alienLightPool.push(bullet.light);
                }
                bullet.light = null;
            }
        }
        
        function resetParticle(particle) {
            particle.lifetime = 0.5 + Math.random() * 0.5;
            particle.velocity.set(
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5
            );
            particle.mesh.material.opacity = 1;
            particle.mesh.material.size = particle.baseSize + Math.random() * 0.1;
        }
        
        // Ajout : Power-Up (CDC 6.4)
        function resetPowerUp(powerUp) {
            powerUp.lifetime = 10.0;
            powerUp.velocity.set(0, -2, 0);
            
            const rand = Math.random();
            if (rand < 0.4) {
                powerUp.powerUpType = 'rapid_fire';
                powerUp.mesh.material = powerUpMatRapid;
            } else if (rand < 0.8) {
                powerUp.powerUpType = 'spread_shot';
                powerUp.mesh.material = powerUpMatSpread;
            } else {
                powerUp.powerUpType = 'shield';
                powerUp.mesh.material = powerUpMatShield;
            }
            powerUp.mesh.rotation.x = Math.random() * Math.PI;
            powerUp.mesh.rotation.y = Math.random() * Math.PI;
        }

        // --- 4.3 Création des Entités initiales (Joueur, Aliens) ---
        
        // MODIFIÉ (CDC 10.1) : NOUVEAU DESIGN DE VAISSEAU AAA 2025
        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            // Matériaux métalliques améliorés
            const darkGray = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
            const lightGray = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6, roughness: 0.4 });
            // Matériau de réacteur émissif (pour le Bloom)
            const brightBlue = new THREE.MeshStandardMaterial({ 
                color: 0x00aaff, 
                emissive: 0x00aaff, // Brille
                emissiveIntensity: 3 
            });
            const redGlass = new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.7, roughness: 0.2, emissive: 0x330000 });
            
            // Corps principal 
            const bodyShape = new THREE.Shape();
            bodyShape.moveTo(0, 0.5);
            bodyShape.lineTo(0.8, 0);
            bodyShape.lineTo(0, -0.5);
            bodyShape.lineTo(-0.8, 0);
            bodyShape.lineTo(0, 0.5);
            const bodyGeometry = new THREE.ExtrudeGeometry(bodyShape, { depth: 0.5, bevelEnabled: false });
            const body = new THREE.Mesh(bodyGeometry, darkGray);
            body.rotation.x = Math.PI / 2;
            body.position.z = -0.25;
            playerGroup.add(body);

            // Cockpit 
            const cockpitGeometry = new THREE.SphereGeometry(0.3, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const cockpit = new THREE.Mesh(cockpitGeometry, redGlass);
            cockpit.position.set(0, 0.2, 0.2);
            playerGroup.add(cockpit);

            // Ailes latérales
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.lineTo(1.5, 0.2);
            wingShape.lineTo(1.5, -0.2);
            wingShape.lineTo(0, -0.4);
            wingShape.lineTo(0, 0);
            const wingGeometry = new THREE.ExtrudeGeometry(wingShape, { depth: 0.2, bevelEnabled: false });
            
            const leftWing = new THREE.Mesh(wingGeometry, lightGray);
            leftWing.position.set(-1.0, 0, 0);
            leftWing.rotation.y = Math.PI; 
            playerGroup.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeometry, lightGray);
            rightWing.position.set(1.0, 0, 0);
            playerGroup.add(rightWing);
            
            // Canons latéraux
            const canonGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
            const canonMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.9, roughness: 0.3 });
            
            const leftCanon = new THREE.Mesh(canonGeometry, canonMaterial);
            leftCanon.position.set(-0.8, 0.5, 0);
            leftCanon.rotation.x = Math.PI / 2;
            playerGroup.add(leftCanon);

            const rightCanon = new THREE.Mesh(canonGeometry, canonMaterial);
            rightCanon.position.set(0.8, 0.5, 0);
            rightCanon.rotation.x = Math.PI / 2;
            playerGroup.add(rightCanon);

            // Réacteurs arrière (effets lumineux)
            const jetGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.4, 8);
            const jet = new THREE.Mesh(jetGeometry, brightBlue);
            jet.position.set(0, -0.7, 0);
            jet.rotation.x = Math.PI / 2;
            playerGroup.add(jet);
            
            // AJOUT: Lumière du réacteur (pour le Bloom)
            const jetLight = new THREE.PointLight(0x00aaff, 2, 5);
            jetLight.position.set(0, -0.8, 0);
            playerGroup.add(jetLight);
            
            playerGroup.scale.set(1.2, 1.2, 1.2); 
            playerGroup.position.y = -gameSize.height / 2 + 2;
            
            const audioNode = audioEngine.createSpatialNode();
            
            // Bouclier personnel (CDC 6.4) - Look amélioré
            const shieldGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const shieldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, 
                emissive: 0x00ffff,
                emissiveIntensity: 1,
                transparent: true, 
                opacity: 0.3,
                wireframe: true 
            });
            const playerShieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            playerShieldMesh.visible = false; 
            playerGroup.add(playerShieldMesh);

            player = {
                mesh: playerGroup, 
                active: true,
                type: 'player',
                collider: new THREE.Box3(),
                audioNode: audioNode,
                fireCooldown: 0,
                baseFireRate: 0.2,
                fireRate: 0.2,
                powerUpState: 'none',
                powerUpTimer: 0,
                targetRotationY: 0,
                targetRotationX: 0,
                currentRotationY: 0,
                currentRotationX: 0,
                shield: { 
                    active: false,
                    mesh: playerShieldMesh
                }
            };
            scene.add(player.mesh);
            entities.push(player);
        }

        function createAlien(x, y) {
            const isTough = Math.random() < alienGrid.toughAlienChance;
            const alienHealth = isTough ? 2 : 1;
            // Utilise le nouveau matériau
            const alienMaterial = isTough ? alienMatTough : alienMatNormal;
            
            // Utilise la nouvelle géométrie
            const mesh = new THREE.Mesh(alienGeometry, alienMaterial.clone());
            mesh.position.set(x, y, 0);
            
            const audioNode = audioEngine.createSpatialNode();

            const alien = {
                mesh: mesh,
                active: true,
                type: 'alien',
                collider: new THREE.Box3(),
                audioNode: audioNode,
                health: alienHealth,
                baseMaterial: alienMaterial 
            };
            scene.add(mesh);
            entities.push(alien);
            alienGrid.aliens.push(alien);
        }

        // Création du Boss (CDC 6.3) - Design amélioré
        function createBoss() {
            alienGrid.aliens.forEach(a => {
                if (a.mesh) scene.remove(a.mesh);
                a.active = false;
            });
            alienGrid.aliens = [];
            
            // Groupe pour le boss
            const bossGroup = new THREE.Group();
            
            // Matériau du boss (métallique, émissif)
            const bossMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x880000, 
                metalness: 0.9, 
                roughness: 0.2,
                emissive: 0x330000,
                emissiveIntensity: 2
            });
            
            // Corps central
            const bodyGeo = new THREE.BoxGeometry(6, 2, 2);
            const body = new THREE.Mesh(bodyGeo, bossMaterial);
            bossGroup.add(body);
            
            // Canons latéraux
            const canonGeo = new THREE.CylinderGeometry(0.5, 0.5, 2, 12);
            const leftCanon = new THREE.Mesh(canonGeo, bossMaterial);
            leftCanon.position.set(-3, 0, 0);
            leftCanon.rotation.z = Math.PI / 2;
            bossGroup.add(leftCanon);
            
            const rightCanon = new THREE.Mesh(canonGeo, bossMaterial);
            rightCanon.position.set(3, 0, 0);
            rightCanon.rotation.z = Math.PI / 2;
            bossGroup.add(rightCanon);
            
            bossGroup.position.set(0, gameSize.height / 2 + 5, 0); // Commence hors écran
            
            const audioNode = audioEngine.createSpatialNode();
            
            boss = {
                mesh: bossGroup, // Utilise le groupe
                active: true,
                type: 'boss',
                collider: new THREE.Box3(),
                audioNode: audioNode,
                maxHealth: 50 + (currentLevel * 10),
                health: 50 + (currentLevel * 10),
                baseMaterial: bossMaterial,
                fsm: {
                    state: 'ENTERING', 
                    timer: 3.0,
                    targetY: gameSize.height / 2 - 4 
                },
                fireCooldown: 0.1
            };
            scene.add(boss.mesh);
            entities.push(boss);
            
            bossHealthBar.style.display = 'block';
            updateHUD();
        }

        // Boucliers (CDC 6.5) - Nouveau design
        function createShields() {
            const positions = [-6, -2, 2, 6]; // Positions X
            
            for (const x of positions) {
                // Utilise la nouvelle géométrie (cylindre horizontal)
                const mesh = new THREE.Mesh(shieldGeometry, shieldMaterial.clone());
                mesh.position.set(x, -gameSize.height / 2 + 5, 0);
                
                const shield = {
                    mesh: mesh,
                    active: true,
                    type: 'shield',
                    collider: new THREE.Box3(),
                    health: 10 
                };
                scene.add(mesh);
                shields.push(shield);
                entities.push(shield);
            }
        }
        
        // Vaisseau Mystère (UFO) (CDC 5.3) - Nouveau design
        function createUFO() {
            if (ufo) return; 

            // Utilise la nouvelle géométrie (Torus)
            const mesh = new THREE.Mesh(ufoGeometry, ufoMaterial);
            mesh.position.set(-gameSize.width / 2 - 2, gameSize.height / 2 - 1, 0); 
            
            ufo = {
                mesh: mesh,
                active: true,
                type: 'ufo',
                collider: new THREE.Box3(),
                velocity: new THREE.Vector3(3, 0, 0),
                health: 1
            };
            scene.add(mesh);
            entities.push(ufo);
        }

        function createAlienGrid() {
            alienGrid.speed = alienGrid.baseSpeed + (currentLevel * 0.05);
            alienGrid.fireRate = Math.min(0.1, alienGrid.baseFireRate + (currentLevel * 0.002));
            alienGrid.toughAlienChance = Math.min(0.6, 0.2 + (currentLevel * 0.02));

            const rows = Math.min(5, 3 + Math.floor(currentLevel / 3)); 
            const cols = 8;
            const startX = - (cols / 2) * 1.5 + 0.75;
            const startY = gameSize.height / 2 - 3;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    createAlien(startX + c * 1.5, startY - r * 1.5);
                }
            }
        }
        
        // AJOUT (CDC 4.3) : Arrière-plan "Starfield" (Amélioré)
        function createStarfield(count = 5000, size = 0.1, zPos = -50) {
            const starCount = count;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                positions[i * 3    ] = (Math.random() - 0.5) * 100; // x
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100; // y
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50 + zPos; // z (profondeur)
            }
            
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: size,
                transparent: true,
                opacity: 0.8,
                depthWrite: false
            });
            
            const field = new THREE.Points(starGeometry, starMaterial);
            scene.add(field);
            return field;
        }
        
        // AJOUT: Nébuleuse (simulée avec des points)
        function createNebula() {
            const nebulaCount = 1000;
            const positions = new Float32Array(nebulaCount * 3);
            const colors = new Float32Array(nebulaCount * 3);
            const color = new THREE.Color();
            
            const nebulaColors = [new THREE.Color(0xaa00ff), new THREE.Color(0x00aaff), new THREE.Color(0xff00aa)];

            for (let i = 0; i < nebulaCount; i++) {
                // Position en "nuage"
                positions[i * 3    ] = (Math.random() - 0.5) * 40; // x
                positions[i * 3 + 1] = (Math.random() - 0.5) * 20 + 5; // y (centré haut)
                positions[i * 3 + 2] = -60 - Math.random() * 20; // z (très loin)
                
                // Couleur aléatoire
                const c = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
                color.set(c);
                colors[i * 3    ] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            const nebulaGeometry = new THREE.BufferGeometry();
            nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const nebulaMaterial = new THREE.PointsMaterial({
                size: 5, // Grosses particules
                transparent: true,
                opacity: 0.05, // Très faible opacité
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: true // Utilise les couleurs définies
            });
            
            nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
            scene.add(nebula);
        }
        
        // --- 4.4 "Juiciness" : Screenshake (CDC Section 7.1) ---
        let shake = { intensity: 0, duration: 0 };
        function triggerScreenshake(intensity, duration) {
            shake.intensity = Math.max(shake.intensity, intensity);
            shake.duration = Math.max(shake.duration, duration);
        }

        // --- 4.5 "Juiciness" : Particules (CDC Section 7.3) ---
        function createExplosion(position, count, color) {
            for (let i = 0; i < count; i++) {
                const p = particlePool.get();
                p.mesh.position.copy(position);
                p.mesh.material.color.set(color);
            }
        }

        // =====================================================================
        // 5. SYSTÈMES (Logique de la boucle de jeu) (CDC Section 3.3)
        // =====================================================================

        // --- 5.1 PlayerSystem / InputSystem ---
        function updatePlayer(dt) {
            if (!player || !player.active) return;

            const speed = 7;
            let currentMoveX = 0;

            if (input.left) {
                player.mesh.position.x -= speed * dt;
                currentMoveX = -1;
            }
            if (input.right) {
                player.mesh.position.x += speed * dt;
                currentMoveX = 1;
            }
            input.currentMoveX = currentMoveX;

            const halfWidth = gameSize.width / 2;
            player.mesh.position.x = Math.max(-halfWidth, Math.min(halfWidth, player.mesh.position.x));

            if (player.audioNode && audioContext) {
                player.audioNode.positionX.setValueAtTime(player.mesh.position.x, audioContext.currentTime);
            }

            if (player.powerUpTimer > 0) {
                player.powerUpTimer -= dt;
                if (player.powerUpTimer <= 0) {
                    player.powerUpState = 'none';
                    player.fireRate = player.baseFireRate;
                }
            }

            player.shield.mesh.visible = player.shield.active;
            if(player.shield.active) {
                player.shield.mesh.rotation.y += dt * 0.5;
            }

            player.fireCooldown -= dt;
            if (input.fire && player.fireCooldown <= 0) {
                player.fireCooldown = player.fireRate;
                
                switch (player.powerUpState) {
                    case 'spread_shot':
                        spawnPlayerBullet(0, 15, 0); 
                        spawnPlayerBullet(-5, 14, 0); 
                        spawnPlayerBullet(5, 14, 0);  
                        break;
                    
                    case 'rapid_fire':
                    case 'none':
                    default:
                        spawnPlayerBullet(0, 15, 0);
                        break;
                }
                
                audioEngine.playSound('shoot', player.audioNode);
            }
        }

        // Fonction utilitaire pour le tir
        function spawnPlayerBullet(velX, velY, velZ) {
            const bullet = bulletPool.get();
            bullet.isPlayerBullet = true;
            bullet.mesh.material = playerBulletMaterial;
            bullet.mesh.position.copy(player.mesh.position).y += 0.5;
            bullet.velocity.set(velX, velY, velZ); 
            
            // CORRECTION: Assigner la lumière ICI
            bullet.light = playerLightPool.pop() || new THREE.PointLight(0x00ff00, 5, 4); // AUGMENTÉ: Intensité 1->5, Distance 3->4
            bullet.light.intensity = 5; // AUGMENTÉ
            bullet.light.visible = true;
            bullet.mesh.add(bullet.light);
        }

        // --- 5.2 AlienAISystem (CDC Section 6.1 / 5.2) ---
        function updateAliens(dt) {
            if (alienGrid.aliens.length === 0 || boss) return;

            let hitEdge = false;
            const halfWidth = gameSize.width / 2;

            for (const alien of alienGrid.aliens) {
                if (!alien.active) continue;
                
                let moveY = 0;
                if (alienGrid.moveDown) {
                    moveY = -1.0; 
                }
                alien.mesh.position.x += alienGrid.direction * alienGrid.speed * dt;
                alien.mesh.position.y += moveY;
                
                if (alien.audioNode && audioContext) {
                    alien.audioNode.positionX.setValueAtTime(alien.mesh.position.x, audioContext.currentTime);
                }
                
                if (alien.mesh.position.x > halfWidth || alien.mesh.position.x < -halfWidth) {
                    hitEdge = true;
                }
                
                if (Math.random() < alienGrid.fireRate * dt) {
                     const bullet = bulletPool.get();
                     bullet.isPlayerBullet = false;
                     bullet.mesh.material = alienBulletMaterial;
                     bullet.mesh.position.copy(alien.mesh.position).y -= 0.5;
                     bullet.velocity.set(0, -5, 0);
                     
                     // CORRECTION: Assigner la lumière ICI
                     bullet.light = alienLightPool.pop() || new THREE.PointLight(0xff0000, 5, 4); // AUGMENTÉ: Intensité 1->5, Distance 3->4
                     bullet.light.intensity = 5; // AUGMENTÉ
                     bullet.light.visible = true;
                     bullet.mesh.add(bullet.light);
                }
                
                if (alien.mesh.position.y < player.mesh.position.y) {
                    setGameState(GAME_STATE.GAME_OVER);
                }
            }

            if (alienGrid.moveDown) {
                alienGrid.moveDown = false;
            }
            
            if (hitEdge) {
                alienGrid.direction *= -1; 
                alienGrid.moveDown = true;
                alienGrid.speed *= 1.05;
            }
        }
        
        // IA du Boss (CDC 6.3 / 6.1)
        function updateBoss(dt) {
            if (!boss || !boss.active) return;
            
            const state = boss.fsm.state;
            boss.fsm.timer -= dt;
            
            switch(state) {
                case 'ENTERING':
                    boss.mesh.position.y = THREE.MathUtils.lerp(boss.mesh.position.y, boss.fsm.targetY, 0.05);
                    if (boss.fsm.timer <= 0) {
                        boss.fsm.state = 'ATTACKING';
                        boss.fsm.timer = 5.0; 
                    }
                    break;
                    
                case 'ATTACKING':
                    // Le matériau émissif devient plus intense
                    boss.baseMaterial.emissive.set(0x880000); // Rouge vif
                    boss.fireCooldown -= dt;
                    if (boss.fireCooldown <= 0) {
                        const positions = [-2, 0, 2];
                        for (const xOffset of positions) {
                            const bullet = bulletPool.get();
                            bullet.isPlayerBullet = false;
                            bullet.mesh.material = alienBulletMaterial;
                            bullet.mesh.position.copy(boss.mesh.position).y -= 1.0;
                            bullet.mesh.position.x += xOffset;
                            bullet.velocity.set(0, -8, 0); 
                            
                            // CORRECTION: Assigner la lumière ICI
                            bullet.light = alienLightPool.pop() || new THREE.PointLight(0xff0000, 5, 4); // AUGMENTÉ: Intensité 1->5, Distance 3->4
                            bullet.light.intensity = 5; // AUGMENTÉ
                            bullet.light.visible = true;
                            bullet.mesh.add(bullet.light);
                        }
                        boss.fireCooldown = 0.3; 
                    }
                    
                    if (boss.fsm.timer <= 0) {
                        boss.fsm.state = 'VULNERABLE';
                        boss.fsm.timer = 3.0; 
                    }
                    break;
                    
                case 'VULNERABLE':
                    // Le matériau émissif s'éteint
                    boss.baseMaterial.emissive.set(0x330000); // Rouge sombre
                    
                    if (boss.fsm.timer <= 0) {
                        boss.fsm.state = 'ATTACKING';
                        boss.fsm.timer = 5.0; 
                    }
                    break;
            }
            
            boss.mesh.position.x = Math.sin(clock.getElapsedTime() * 0.5) * (gameSize.width / 2 - 3);
        }

        // Logique UFO (CDC 5.3)
        function updateUFO(dt) {
            ufoSpawnTimer -= dt;
            if (ufoSpawnTimer <= 0 && !ufo) {
                createUFO();
                ufoSpawnTimer = 15.0 + Math.random() * 10; 
            }
            
            if (ufo && ufo.active) {
                ufo.mesh.position.x += ufo.velocity.x * dt;
                ufo.mesh.rotation.y += dt * 2;
                
                if (ufo.mesh.position.x > gameSize.width / 2 + 2) {
                    scene.remove(ufo.mesh);
                    ufo.active = false; // AJOUT: Doit être désactivé
                    ufo = null;
                }
            }
        }
        
        // --- 5.3 MovementSystem / TimerSystem (CDC Section 3.3) ---
        function updateMovementAndLifetime(dt) {
            const activeBullets = bulletPool.getActiveObjects();
            const activeParticles = particlePool.getActiveObjects();
            const activePowerUps = powerUpPool.getActiveObjects();
            
            const entitiesToUpdate = [...activeBullets, ...activeParticles, ...activePowerUps];
            
            for (const entity of entitiesToUpdate) {
                entity.mesh.position.x += entity.velocity.x * dt;
                entity.mesh.position.y += entity.velocity.y * dt;
                entity.mesh.position.z += entity.velocity.z * dt;

                if (entity.audioNode && audioContext) {
                    entity.audioNode.positionX.setValueAtTime(entity.mesh.position.x, audioContext.currentTime);
                }

                entity.lifetime -= dt;
                if (entity.lifetime <= 0) {
                    if (entity.type === 'bullet') bulletPool.release(entity);
                    if (entity.type === 'particle') particlePool.release(entity);
                    if (entity.type === 'powerup') powerUpPool.release(entity);
                }
                
                if (entity.type === 'particle') {
                    entity.mesh.material.opacity = entity.lifetime * 2; // Fade out
                }
                
                // AJOUT: Rotation des power-ups
                if (entity.type === 'powerup') {
                    entity.mesh.rotation.x += dt;
                    entity.mesh.rotation.y += dt;
                }
            }
        }

        // --- 5.4 CollisionSystem (CDC Section 4.2) ---
        function updateCollisions() {
            const activeBullets = bulletPool.getActiveObjects();
            const activePowerUps = powerUpPool.getActiveObjects();
            
            if (!player || !player.active) return; // Ne pas vérifier les collisions si le joueur est mort
            
            player.collider.setFromObject(player.mesh);
            
            for (const entity of [...alienGrid.aliens, ...activeBullets, ...shields, ...activePowerUps]) {
                if (!entity || !entity.active) continue;
                entity.collider.setFromObject(entity.mesh);
            }
            if (ufo && ufo.active) {
                ufo.collider.setFromObject(ufo.mesh);
            }
            if (boss && boss.active) {
                boss.collider.setFromObject(boss.mesh);
            }

            // 1. Tirs Joueur vs ...
            for (const bullet of activeBullets) {
                if (!bullet.isPlayerBullet || !bullet.active) continue;

                // ... vs Aliens
                for (const alien of alienGrid.aliens) {
                    if (!alien.active) continue;
                    
                    if (bullet.collider.intersectsBox(alien.collider)) {
                        bulletPool.release(bullet);
                        alien.health--;
                        
                        alien.mesh.material.color.set(0xffffff);
                        setTimeout(() => {
                            if (alien.mesh) alien.mesh.material = alien.baseMaterial;
                        }, 50);

                        if (alien.health <= 0) {
                            alien.active = false;
                            scene.remove(alien.mesh);
                            audioEngine.playSound('explosion', alien.audioNode);
                            triggerScreenshake(0.1, 0.2);
                            createExplosion(alien.mesh.position, 30, 0xff00ff);
                            score += 100;
                            updateHUD();
                            
                            if (Math.random() < alienGrid.dropChance) {
                                spawnPowerUp(alien.mesh.position);
                            }
                        }
                    }
                }
                
                // ... vs Boucliers (CDC 6.5)
                for (const shield of shields) {
                    if (!shield.active) continue;
                    if (bullet.collider.intersectsBox(shield.collider)) {
                        bulletPool.release(bullet);
                        shield.health--;
                        shield.mesh.material.opacity = (shield.health / 10) * 0.6; 
                        if (shield.health <= 0) {
                            shield.active = false;
                            scene.remove(shield.mesh);
                            createExplosion(shield.mesh.position, 20, 0x0088ff);
                        }
                    }
                }
                
                // ... vs UFO (CDC 5.3)
                if (ufo && ufo.active && bullet.collider.intersectsBox(ufo.collider)) {
                    bulletPool.release(bullet);
                    ufo.health--;
                    if (ufo.health <= 0) {
                        ufo.active = false;
                        scene.remove(ufo.mesh);
                        ufo = null;
                        score += 500; 
                        updateHUD();
                        triggerScreenshake(0.2, 0.3);
                        createExplosion(bullet.mesh.position, 50, 0xff4444);
                    }
                }
                
                // ... vs Boss (CDC 6.3)
                if (boss && boss.active && bullet.collider.intersectsBox(boss.collider)) {
                    bulletPool.release(bullet);
                    boss.health--;
                    updateHUD(); 
                    
                    boss.baseMaterial.color.set(0xffffff);
                    setTimeout(() => {
                        if (boss.mesh) {
                            boss.baseMaterial.color.set(0x880000); // Revient à la couleur de base
                        }
                    }, 50);
                    
                    if (boss.health <= 0) {
                        boss.active = false;
                        scene.remove(boss.mesh);
                        boss = null;
                        
                        score += 1000; 
                        triggerScreenshake(0.5, 1.0);
                        createExplosion(bullet.mesh.position, 200, 0xff8800);
                        bossHealthBar.style.display = 'none';
                        
                        advanceLevel();
                    }
                }
            }
            
            // 2. Tirs Aliens vs ...
            for (const bullet of activeBullets) {
                if (bullet.isPlayerBullet || !bullet.active) continue;
                
                // CORRECTION: Ajout d'une vérification pour s'assurer que le joueur
                // n'est pas mort pendant cette même boucle
                if (!player.active) break; 

                // ... vs Bouclier Personnel (CDC 6.4)
                if (player.shield.active && bullet.collider.intersectsBox(player.collider)) {
                    bulletPool.release(bullet);
                    player.shield.active = false; 
                    triggerScreenshake(0.1, 0.2);
                    createExplosion(player.mesh.position, 20, 0x00ffff);
                    continue; 
                }

                // ... vs Joueur
                if (bullet.collider.intersectsBox(player.collider)) {
                    bulletPool.release(bullet);
                    lives--;
                    updateHUD();
                    triggerScreenshake(0.3, 0.5);
                    createExplosion(player.mesh.position, 50, 0x00ffff);
                    audioEngine.playSound('hit', player.audioNode);
                    
                    if (lives <= 0) {
                        player.active = false;
                        scene.remove(player.mesh);
                        setGameState(GAME_STATE.GAME_OVER);
                        break; // CORRECTION: Sortir de la boucle, le joueur est mort
                    }
                }
                
                // ... vs Boucliers (CDC 6.5)
                for (const shield of shields) {
                    if (!shield.active) continue;
                    if (bullet.collider.intersectsBox(shield.collider)) {
                        bulletPool.release(bullet);
                        shield.health--;
                        shield.mesh.material.opacity = (shield.health / 10) * 0.6;
                        if (shield.health <= 0) {
                            shield.active = false;
                            scene.remove(shield.mesh);
                            createExplosion(shield.mesh.position, 20, 0x0088ff);
                        }
                    }
                }
            }
            
            // 3. Joueur vs Power-Ups (CDC 6.4)
            if (player.active) {
                for (const powerUp of activePowerUps) {
                    if (powerUp.active && player.collider.intersectsBox(powerUp.collider)) {
                        powerUpPool.release(powerUp);
                        activatePowerUp(powerUp.powerUpType);
                    }
                }
            }
            
            alienGrid.aliens = alienGrid.aliens.filter(a => a.active);
            if (alienGrid.aliens.length === 0 && !boss && currentGameState === GAME_STATE.PLAYING) {
                advanceLevel();
            }
        }
        
        // Système de gestion de niveaux
        function advanceLevel() {
            currentLevel++;
            
            if (currentLevel > 15) {
                currentLevel = 1; 
            }

            if (currentLevel % 3 === 0) {
                createBoss(); 
            } else {
                createAlienGrid();
            }

            updateHUD(); 
        }
        
        // Logique Power-Up (CDC 6.4)
        function spawnPowerUp(position) {
            const p = powerUpPool.get();
            p.mesh.position.copy(position);
        }
        
        function activatePowerUp(type) {
            player.powerUpState = type;
            player.powerUpTimer = 5.0; 
            
            if (type === 'rapid_fire') {
                player.fireRate = player.baseFireRate / 2; 
            } else if (type === 'spread_shot') {
                player.fireRate = player.baseFireRate; 
            } else if (type === 'shield') {
                player.shield.active = true;
            }
        }
        
        // --- 5.5 RenderSystem (CDC Section 3.3 / 7.1) ---
        function updateRender(dt) {
            
            // Animation subtile du vaisseau joueur
            if (player && player.active) {
                player.targetRotationY = -input.currentMoveX * 0.1; 
                player.currentRotationY = THREE.MathUtils.lerp(player.currentRotationY, player.targetRotationY, 0.1);
                player.mesh.rotation.y = player.currentRotationY;

                player.targetRotationX = Math.sin(clock.getElapsedTime() * 2) * 0.05; 
                player.currentRotationX = THREE.MathUtils.lerp(player.currentRotationX, player.targetRotationX, 0.05);
                // Note: La rotation X de base pour l'orientation du modèle est gérée dans createPlayer
            }

            // Mouvement du Starfield (Parallaxe)
            if (starfield) {
                starfield.position.y += dt * 0.2; 
                if (starfield.position.y > 50) starfield.position.y = -50;
            }
            if (starfield2) {
                starfield2.position.y += dt * 0.1; // Plus lent
                if (starfield2.position.y > 50) starfield2.position.y = -50;
            }
            if (nebula) {
                nebula.position.y += dt * 0.05; // Très lent
                if (nebula.position.y > 50) nebula.position.y = -50;
            }
            
            // Rotation des aliens 
            for (const alien of alienGrid.aliens) {
                if (alien.active && alien.mesh) {
                    alien.mesh.rotation.x += dt;
                    alien.mesh.rotation.y += dt;
                }
            }
            
            // Gestion du Screenshake (Section 7.1)
            // Appliqué au compositeur (caméra de passe) pour de meilleurs résultats
            const passCamera = composer.passes[0].camera; // C'est la caméra de RenderPass
            
            if (shake.duration > 0) {
                shake.duration -= dt;
                const s = shake.intensity;
                passCamera.position.x = Math.random() * s - s / 2;
                passCamera.position.z = 10 + Math.random() * s - s / 2;
                passCamera.rotation.z = Math.random() * (s/5) - (s/10);
            } else {
                passCamera.position.x = 0;
                passCamera.position.z = 10;
                passCamera.rotation.z = 0;
            }
            
            // AJOUT: Mise à jour du FilmPass (pour l'animation)
            filmPass.uniforms.time.value += dt;

            // MODIFIÉ: Rendu via le compositeur
            // renderer.render(scene, camera);
            composer.render(dt);
        }

        // =====================================================================
        // 6. GESTION DES ÉTATS ET INITIALISATION
        // =====================================================================

        // --- 6.1 Initialisation (Setup) ---
        async function init() {
            document.getElementById('loading-screen').style.display = 'flex';
            bossHealthBar = document.getElementById('boss-health-bar');
            bossHealthElement = document.getElementById('boss-health');
            
            await audioEngine.init();
            
            scene = new THREE.Scene();
            // Fond bleu nuit très sombre
            scene.background = new THREE.Color(0x000010); 
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10; 
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('game-canvas') 
                // antialias: false, // L'antialiasing est mieux géré par le post-traitement (FXAA/SMAA)
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Ombres (désactivées car coûteuses)
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio); // Meilleure qualité
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // AJOUT: Essentiel pour le bloom !
            
            clock = new THREE.Clock();

            // --- Lumières (Améliorées) ---
            const ambientLight = new THREE.AmbientLight(0x404080, 2); // Ambiance bleutée
            scene.add(ambientLight);
            
            // Lumière principale (soleil lointain)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            // directionalLight.castShadow = true; // Ombres désactivées pour la performance
            scene.add(directionalLight);
            
            // Lumière d'ambiance globale
            const hemiLight = new THREE.HemisphereLight(0x00bfff, 0x002244, 1); // Ciel cyan, sol bleu foncé
            scene.add(hemiLight);
            
            
            // --- Post-Traitement (Bloom) ---
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Effet Bloom !
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.0, // strength
                0.4, // radius
                0.9  // threshold (CORRIGÉ: 0.1 était trop bas, 0.9 ne cible que les objets très lumineux)
            );
            composer.addPass(bloomPass);
            
            // Effet Film (Vignette, Scanlines)
            filmPass = new FilmPass(
                0.35, // noise intensity
                0.2,  // scanline intensity
                648,  // scanline count
                false // grayscale
            );
            composer.addPass(filmPass);


            document.getElementById('loading-text').innerText = 'CHARGEMENT TERMINÉ.';
            
            // Arrière-plan (Parallaxe)
            starfield = createStarfield(5000, 0.1, -50);
            starfield2 = createStarfield(2000, 0.05, -30);
            createNebula();
            
            // Pools
            bulletPool = new ObjectPool(createBulletEntity, resetBullet, 100);
            particlePool = new ObjectPool(createParticleEntity, resetParticle, 200);
            powerUpPool = new ObjectPool(createPowerUpEntity, resetPowerUp, 20); 

            // Gestionnaires d'événements
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            document.getElementById('start-button').addEventListener('click', () => {
                setGameState(GAME_STATE.PLAYING);
            });
            document.getElementById('restart-button').addEventListener('click', () => {
                setGameState(GAME_STATE.MAIN_MENU); // Retour au menu pour recharger
            });
            document.getElementById('resume-button').addEventListener('click', () => {
                setGameState(GAME_STATE.PLAYING);
            });

            // Démarrer la FSM
            setGameState(GAME_STATE.MAIN_MENU);
            
            // Démarrer la boucle de jeu 
            renderer.setAnimationLoop(gameLoop);
        }

        // --- 6.2 Changement d'état (FSM) (Section 9.2) ---
        function setGameState(newState) {
            if (currentGameState === newState) return;

            // Logique de bascule pour la Pause
            if (newState === GAME_STATE.PLAYING && currentGameState === GAME_STATE.PAUSED) {
                document.getElementById('pause-menu').style.display = 'none';
                currentGameState = newState;
                return; 
            }
            if (newState === GAME_STATE.PAUSED && currentGameState === GAME_STATE.PLAYING) {
                document.getElementById('pause-menu').style.display = 'flex';
                currentGameState = newState;
                return; 
            }

            currentGameState = newState;

            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('pause-menu').style.display = 'none'; 

            switch (newState) {
                case GAME_STATE.PRELOADING:
                    document.getElementById('loading-screen').style.display = 'flex';
                    break;
                case GAME_STATE.MAIN_MENU:
                    document.getElementById('main-menu').style.display = 'flex';
                    loadLeaderboard();
                    resetGame(); // Réinitialise le jeu à chaque retour au menu
                    break;
                case GAME_STATE.PLAYING:
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    // Le jeu est déjà réinitialisé depuis MAIN_MENU
                    document.getElementById('hud').style.display = 'flex';
                    break;
                case GAME_STATE.GAME_OVER:
                    document.getElementById('final-score').innerText = `SCORE : ${score}`;
                    document.getElementById('game-over-screen').style.display = 'flex';
                    saveScoreToLeaderboard();
                    bossHealthBar.style.display = 'none'; 
                    break;
            }
        }
        
        // Panneau des scores (CDC 9.6)
        function loadLeaderboard() {
            const scores = JSON.parse(localStorage.getItem('eliteInvaders_leaderboard')) || [];
            const list = document.getElementById('high-score-list');
            list.innerHTML = ''; 
            
            if (scores.length === 0) {
                list.innerHTML = '<li>AUCUN SCORE</li>';
                return;
            }
            
            const topScores = scores.slice(0, 5); 
            
            for (const s of topScores) {
                const li = document.createElement('li');
                li.textContent = s;
                list.appendChild(li);
            }
        }

        // Panneau des scores (CDC 9.6)
        function saveScoreToLeaderboard() {
            const scores = JSON.parse(localStorage.getItem('eliteInvaders_leaderboard')) || [];
            scores.push(score);
            scores.sort((a, b) => b - a); 
            
            const topScores = scores.slice(0, 5);
            
            localStorage.setItem('eliteInvaders_leaderboard', JSON.stringify(topScores));
        }

        // --- 6.3 Réinitialisation du jeu ---
        function resetGame() {
            // Nettoie les entités
            entities.forEach(e => {
                if (e.mesh) scene.remove(e.mesh);
            });
            entities = [];
            alienGrid.aliens = [];
            shields = []; 
            
            bulletPool.getActiveObjects().forEach(b => bulletPool.release(b));
            particlePool.getActiveObjects().forEach(p => particlePool.release(p));
            powerUpPool.getActiveObjects().forEach(p => powerUpPool.release(p));
            
            if (ufo) {
                scene.remove(ufo.mesh);
                ufo = null;
            }
            ufoSpawnTimer = 15.0;
            
            if (boss) {
                scene.remove(boss.mesh);
                boss = null;
            }
            bossHealthBar.style.display = 'none';
            
            // Recrée le joueur, les aliens et les boucliers
            createPlayer();
            createAlienGrid();
            createShields();
            
            // Réinitialise les stats
            score = 0;
            lives = 55; // MODIFIÉ: 3 -> 55
            currentLevel = 1; 
            alienGrid.speed = alienGrid.baseSpeed; 
            alienGrid.direction = 1;
            updateHUD();
        }

        // --- 6.4 Boucle de Jeu Principale ---
        function gameLoop() {
            deltaTime = clock.getDelta();

            if (currentGameState === GAME_STATE.PLAYING) {
                updatePlayer(deltaTime);
                if (boss) {
                    updateBoss(deltaTime);
                } else {
                    updateAliens(deltaTime);
                }
                updateUFO(deltaTime); 
                updateMovementAndLifetime(deltaTime);
                updateCollisions();
            }
            
            if (currentGameState !== GAME_STATE.PRELOADING) {
                updateRender(deltaTime);
            }
        }

        // --- 6.5 Gestionnaires d'événements (Input) ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // AJOUT: Mettre à jour le compositeur
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    input.left = true;
                    break;
                case 'ArrowRight':
                case 'KeyD': 
                    input.right = true; 
                    break; 
                case 'Space': 
                case 'ArrowUp': 
                case 'KeyW':
                    input.fire = true;
                    break;
                case 'Escape':
                    if (currentGameState === GAME_STATE.PLAYING) {
                        setGameState(GAME_STATE.PAUSED);
                    } else if (currentGameState === GAME_STATE.PAUSED) {
                        setGameState(GAME_STATE.PLAYING);
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    input.left = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    input.right = false;
                    break;
                case 'Space':
                case 'ArrowUp':
                case 'KeyW':
                    input.fire = false;
                    break;
            }
        }
        
        // --- 6.6 UI (HUD) ---
        function updateHUD() {
            document.getElementById('score').innerText = `SCORE : ${score}`;
            document.getElementById('lives').innerText = `VIES : ${lives}`;
            document.getElementById('level').innerText = `NIVEAU : ${currentLevel}`; 
            
            if (boss && boss.active) {
                const healthPercent = (boss.health / boss.maxHealth) * 100;
                bossHealthElement.style.width = `${healthPercent}%`;
            }
        }

        // --- Démarrage ---
        init();

    </script>
</body>
</html>








