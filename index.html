<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elite Invaders 3D</title>
    <!-- 
      Conformément au CDC (Section 9.1), nous utilisons une superposition HTML/CSS 
      pour l'interface utilisateur (UI) par-dessus le canvas du jeu.
    --><style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden; /* Empêche le défilement */
        }

        /* Conteneur principal qui superpose l'UI et le Canvas */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* Le canvas de rendu 3D (remplace la pile multi-canvas 2D) */
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* L'équivalent de image-rendering: pixelated pour la 3D est géré par le renderer */
        }

        /* Superposition de l'UI (Section 9.1) */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* Par défaut, l'UI ne capture pas les clics (sauf les menus) */
            pointer-events: none; 
        }

        /* Menus qui doivent être cliquables */
        .menu {
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            pointer-events: auto; /* Réactive les événements pour ce menu */
            box-shadow: 0 0 20px #0f0;
        }

        .menu h1 {
            margin-top: 0;
            color: #0f0;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        /* AJOUT: Style pour le panneau des scores */
        #leaderboard {
            width: 80%;
            margin: 20px auto;
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 10px;
        }
        #leaderboard h2 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
            color: #fff;
        }
        #high-score-list {
            list-style-type: decimal;
            padding-left: 30px;
            margin: 0;
            text-align: left;
            font-size: 1.1em;
        }
        #high-score-list li {
            margin-bottom: 5px;
        }

        .menu button {
            background-color: #0f0;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s, box-shadow 0.3s;
        }

        .menu button:hover {
            background-color: #fff;
            box-shadow: 0 0 15px #fff;
        }

        /* HUD en jeu (Section 9.1) */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 1.5em;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            display: none; /* Caché par défaut */
        }

        /* AJOUT: Barre de vie du Boss (CDC 9.3) */
        #boss-health-bar {
            position: absolute;
            top: 80px; /* Sous le HUD principal */
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            height: 20px;
            background-color: #333;
            border: 2px solid #f00;
            border-radius: 5px;
            display: none; /* Caché par défaut */
        }
        #boss-health {
            width: 100%;
            height: 100%;
            background-color: #f00;
            border-radius: 2px;
            transition: width 0.2s ease-out;
        }

        /* Écrans de la FSM Globale (Section 9.2) */
        #main-menu { display: flex; }
        #game-over-screen { display: none; }
        #loading-screen { display: flex; }
        #pause-menu { display: none; } /* AJOUT: État de pause */

    </style>
</head>
<body>

    <!-- 
      Structure HTML (Section 9.1)
      - game-container : Conteneur principal
      - game-canvas : Rendu 3D (Three.js)
      - ui-overlay : Superposition HTML pour l'UI
    --><div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="ui-overlay">
            
            <!-- État PRELOADING (Section 9.4) --><div id="loading-screen" class="menu">
                <h1>ELITE INVADERS 3D</h1>
                <p id="loading-text">CHARGEMENT DES RESSOURCES...</p>
            </div>

            <!-- État MAIN_MENU (Section 9.2) --><div id="main-menu" class="menu" style="display: none;">
                <h1>ELITE INVADERS 3D</h1>
                <!-- MODIFIÉ: Panneau des scores (CDC 9.6) -->
                <div id="leaderboard">
                    <h2>MEILLEURS SCORES</h2>
                    <ol id="high-score-list">
                        <li>---</li>
                        <li>---</li>
                        <li>---</li>
                    </ol>
                </div>
                <button id="start-button">COMMENCER LA MISSION</button>
            </div>

            <!-- État GAME_OVER (Section 9.2) --><div id="game-over-screen" class="menu" style="display: none;">
                <h1>MISSION ÉCHOUÉE</h1>
                <p id="final-score">SCORE : 0</p>
                <button id="restart-button">RÉESSAYER</button>
            </div>

            <!-- AJOUT: État PAUSED (CDC 9.2) --><div id="pause-menu" class="menu" style="display: none;">
                <h1>PAUSE</h1>
                <button id="resume-button">REPRENDRE</button>
            </div>

            <!-- HUD (Head-Up Display) (Section 9.1) --><div id="hud">
                <div id="score">SCORE : 0</div>
                <!-- AJOUT: Affichage du niveau -->
                <div id="level">NIVEAU : 1</div>
                <div id="lives">VIES : 3</div>
            </div>

            <!-- AJOUT: Barre de vie du Boss (CDC 9.3) -->
            <div id="boss-health-bar">
                <div id="boss-health"></div>
            </div>

        </div>
    </div>

    <!-- 
      Importation de Three.js (bibliothèque de rendu 3D).
      Le CDC spécifie "sans framework de jeu", mais Three.js est une
      bibliothèque de rendu, nécessaire pour la 3D. L'architecture ECS 
      sera la nôtre.
    --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // =====================================================================
        // 1. FONDATIONS TECHNIQUES ET ARCHITECTURE (CDC Sections 2, 3)
        // =====================================================================

        // --- 1.1 Moteurs 3D (Three.js) ---
        let scene, camera, renderer, clock;
        let gameSize = { width: 20, height: 20 }; // Taille de la zone de jeu en unités 3D
        
        // --- 1.2 Boucle de Jeu (Game Loop) (CDC Section 2.2) ---
        // `rAF` est géré par le `renderer.setAnimationLoop` de Three.js
        let deltaTime = 0;

        // --- 1.3 FSM Globale (Gestionnaire d'état) (CDC Section 9.2) ---
        const GAME_STATE = {
            PRELOADING: 'PRELOADING',
            MAIN_MENU: 'MAIN_MENU',
            PLAYING: 'PLAYING',
            PAUSED: 'PAUSED', // AJOUT: État de pause (CDC 9.2)
            GAME_OVER: 'GAME_OVER'
        };
        let currentGameState = GAME_STATE.PRELOADING;

        // --- 1.4 Architecture ECS (simplifiée) (CDC Section 3) ---
        // Pour un seul fichier, une ECS formelle est lourde.
        // Nous utilisons une approche à base de composants (objets)
        // et de systèmes (fonctions) qui itèrent sur des listes.
        let entities = []; // Remplace l'EntityManager
        let player = null;
        let alienGrid = {
            aliens: [],
            direction: 1, // 1 pour droite, -1 pour gauche
            speed: 0.5,
            baseSpeed: 0.5, // Pour la difficulté progressive
            moveDown: false,
            fireRate: 0.02, // Chance de tirer par alien par frame
            baseFireRate: 0.02, // Pour la difficulté progressive
            dropChance: 0.2, // 20% de chance de lâcher un power-up
            toughAlienChance: 0.2 // 20% de chance qu'un alien soit "renforcé"
        };
        
        // --- 1.5 Gestion des Entrées (InputSystem) (CDC Section 3.3) ---
        const input = {
            left: false,
            right: false,
            fire: false,
            // AJOUT: Pour simuler des mouvements subtils du vaisseau
            currentMoveX: 0 
        };

        // --- 1.6 Statistiques de jeu ---
        let score = 0;
        let lives = 3;
        let currentLevel = 1; // AJOUT: Système de niveaux

        // --- 1.7 Entités de jeu supplémentaires ---
        let shields = [];
        let ufo = null;
        let ufoSpawnTimer = 15.0; // 15 secondes
        let starfield; // Pour l'arrière-plan
        let boss = null; // AJOUT: Variable pour le boss
        let bossHealthBar, bossHealthElement; // AJOUT: Éléments DOM pour la vie du boss

        // =====================================================================
        // 2. AUDIO (CDC Section 8)
// ... (pas de changement dans cette section) ...
        // =====================================================================
        // 2. AUDIO (CDC Section 8)
        // =====================================================================
        
        // --- 2.1 Web Audio API (CDC Section 8.1) ---
        let audioContext;
        let sfxGain; // GainNode pour les SFX
        let musicGain; // GainNode pour la musique
        const audioBuffers = {}; // Stockage des sons pré-chargés

        class AudioEngine {
            async init() {
                if (audioContext) return; // Déjà initialisé
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Création des nœuds de mixage (Section 8.1)
                sfxGain = audioContext.createGain();
                musicGain = audioContext.createGain();
                
                sfxGain.gain.value = 0.7;
                musicGain.gain.value = 0.3;

                sfxGain.connect(audioContext.destination);
                musicGain.connect(audioContext.destination);
            }

            // Pré-chargement (Section 9.4)
            async loadSound(name, url) {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    audioBuffers[name] = audioBuffer;
                } catch (e) {
                    console.error(`Erreur lors du chargement du son ${name}:`, e);
                }
            }

            // Jouer un son (AudioSystem)
            playSound(name, spatialNode = null) {
                if (!audioBuffers[name] || !audioContext) return;
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffers[name];

                // Gestion de la spatialisation (Section 8.2)
                if (spatialNode) {
                    source.connect(spatialNode);
                    spatialNode.connect(sfxGain);
                } else {
                    source.connect(sfxGain);
                }
                source.start(0);
            }
            
            // Crée un nœud de spatialisation 3D (PannerNode)
            createSpatialNode() {
                // Pour la 3D, PannerNode est plus complexe,
                // On utilise un simple Gain pour cet exemple.
                // Dans une version complète, on utiliserait PannerNode
                // et on mettrait à jour sa position.
                const panner = audioContext.createPanner();
                panner.panningModel = 'HRTF';
                panner.distanceModel = 'inverse';
                panner.refDistance = 1;
                panner.maxDistance = 100;
                panner.rolloffFactor = 1;
                panner.coneInnerAngle = 360;
                panner.coneOuterAngle = 0;
                panner.coneOuterGain = 0;
                return panner;
            }
        }
        const audioEngine = new AudioEngine();

        // =====================================================================
        // 3. OPTIMISATION : OBJECT POOLING (CDC Section 4.1)
        // =====================================================================
        
        // Géométrie et Matériaux partagés
        // MODIFIÉ (CDC 7.2) : Remplacé Sphère par Cylindre pour des tirs "laser"
        const bulletGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
        const playerBulletMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const alienBulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0], 3));
        const particleMaterial = new THREE.PointsMaterial({ 
            color: 0xffaa00, 
            size: 0.1, 
            transparent: true,
            blending: THREE.AdditiveBlending 
        });
        
        // Nouveaux matériaux pour les fonctionnalités
        const shieldMaterial = new THREE.MeshLambertMaterial({ color: 0x0088ff, transparent: true, opacity: 0.8 });
        const powerUpGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const powerUpMatRapid = new THREE.MeshLambertMaterial({ color: 0xffff00 }); // Jaune pour Rapid
        const powerUpMatSpread = new THREE.MeshLambertMaterial({ color: 0x00ffff }); // Cyan pour Spread
        const powerUpMatShield = new THREE.MeshLambertMaterial({ color: 0x0088ff }); // AJOUT: Bleu pour Bouclier
        const ufoGeometry = new THREE.SphereGeometry(0.6, 12, 6);
        const ufoMaterial = new THREE.MeshLambertMaterial({ color: 0xff4444 });
        
        // Nouveaux matériaux pour les aliens
        const alienMatNormal = new THREE.MeshLambertMaterial({ color: 0xff00ff }); // Magenta (normal)
        const alienMatTough = new THREE.MeshLambertMaterial({ color: 0xff8800 }); // Orange (renforcé)


        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 50) {
                this.pool = [];
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.expandPool(initialSize);
            }

            expandPool(size) {
                for (let i = 0; i < size; i++) {
                    const obj = this.createFn();
                    obj.active = false;
                    scene.add(obj.mesh); // Ajoute le mesh à la scène une fois
                    this.pool.push(obj);
                }
            }

            get() {
                let obj = this.pool.find(o => !o.active);
                if (!obj) {
                    // Si le pool est vide, on l'agrandit (moins idéal que le pré-allocage)
                    this.expandPool(Math.floor(this.pool.length * 0.5));
                    obj = this.pool.find(o => !o.active);
                }
                
                obj.active = true;
                obj.mesh.visible = true;
                this.resetFn(obj);
                return obj;
            }

            release(obj) {
                obj.active = false;
                obj.mesh.visible = false;
                obj.mesh.position.set(0, -100, 0); // Déplace hors champ
            }

            getActiveObjects() {
                return this.pool.filter(o => o.active);
            }
        }

        // Définition des pools
        let bulletPool, particlePool, powerUpPool;

        // =====================================================================
        // 4. ENTITÉS ET SYSTÈMES DE JEU (CDC Sections 3, 5, 6, 7)
        // =====================================================================

        // --- 4.1 Fonctions de création (pour les pools) ---

        function createBulletEntity() {
            const mesh = new THREE.Mesh(bulletGeometry); // Géométrie partagée
            const audioNode = audioEngine.createSpatialNode();
            // mesh.add(audioNode); // Erreur: Un PannerNode (Web Audio) n'est pas un Object3D (Three.js)
            
            const entity = {
                mesh: mesh,
                active: false,
                type: 'bullet',
                isPlayerBullet: true,
                velocity: new THREE.Vector3(0, 5, 0),
                lifetime: 2, // en secondes
                collider: new THREE.Box3(),
                audioNode: audioNode
            };
            entities.push(entity);
            return entity;
        }
        
        function createParticleEntity() {
            const mesh = new THREE.Points(particleGeometry, particleMaterial.clone());
            const entity = {
                mesh: mesh,
                active: false,
                type: 'particle',
                velocity: new THREE.Vector3(),
                lifetime: 0.5,
                baseSize: 0.1
                // Pas d'audioNode pour les particules
            };
            entities.push(entity);
            return entity;
        }

        // Ajout : Power-Up (CDC 6.4)
        function createPowerUpEntity() {
            const mesh = new THREE.Mesh(powerUpGeometry, powerUpMatRapid.clone()); // Matériau par défaut
            const entity = {
                mesh: mesh,
                active: false,
                type: 'powerup',
                velocity: new THREE.Vector3(0, -2, 0), // Tombe
                lifetime: 10.0, // 10 secondes pour le ramasser
                collider: new THREE.Box3(),
                powerUpType: 'rapid_fire' // Type par défaut
            };
            entities.push(entity);
            return entity;
        }

        // --- 4.2 Fonctions de "Reset" (pour les pools) ---

        function resetBullet(bullet) {
            bullet.lifetime = 2;
            // MODIFIÉ : Oriente le laser correctement
            bullet.mesh.rotation.x = Math.PI / 2;
        }
        
        function resetParticle(particle) {
            particle.lifetime = 0.5 + Math.random() * 0.5;
            particle.velocity.set(
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5
            );
            particle.mesh.material.opacity = 1;
            particle.mesh.material.size = particle.baseSize + Math.random() * 0.1;
        }
        
        // Ajout : Power-Up (CDC 6.4)
        function resetPowerUp(powerUp) {
            powerUp.lifetime = 10.0;
            powerUp.velocity.set(0, -2, 0);
            
            // MODIFIÉ: Randomise le type de power-up (CDC 6.4)
            const rand = Math.random();
            if (rand < 0.4) {
                powerUp.powerUpType = 'rapid_fire';
                powerUp.mesh.material = powerUpMatRapid;
            } else if (rand < 0.8) {
                powerUp.powerUpType = 'spread_shot';
                powerUp.mesh.material = powerUpMatSpread;
            } else {
                // AJOUT: Nouveau power-up Bouclier
                powerUp.powerUpType = 'shield';
                powerUp.mesh.material = powerUpMatShield;
            }
            powerUp.mesh.rotation.x = Math.random() * Math.PI;
            powerUp.mesh.rotation.y = Math.random() * Math.PI;
        }

        // --- 4.3 Création des Entités initiales (Joueur, Aliens) ---
        
        // MODIFIÉ (CDC 10.1) : NOUVEAU DESIGN DE VAISSEAU AAA 2025
        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            const darkGray = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
            const lightGray = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6, roughness: 0.4 });
            const brightBlue = new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x002244, emissiveIntensity: 0.5 });
            const redGlass = new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.7, roughness: 0.2 });
            
            // Corps principal : forme de coin ou de diamant
            const bodyShape = new THREE.Shape();
            bodyShape.moveTo(0, 0.5);
            bodyShape.lineTo(0.8, 0);
            bodyShape.lineTo(0, -0.5);
            bodyShape.lineTo(-0.8, 0);
            bodyShape.lineTo(0, 0.5);
            const bodyGeometry = new THREE.ExtrudeGeometry(bodyShape, { depth: 0.5, bevelEnabled: false });
            const body = new THREE.Mesh(bodyGeometry, darkGray);
            body.rotation.x = Math.PI / 2;
            body.position.z = -0.25; // Centre la profondeur
            playerGroup.add(body);

            // Cockpit bulbeux en verre
            const cockpitGeometry = new THREE.SphereGeometry(0.3, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const cockpit = new THREE.Mesh(cockpitGeometry, redGlass);
            cockpit.position.set(0, 0.2, 0.2);
            playerGroup.add(cockpit);

            // Ailes latérales avec détail de réacteur/propulsion
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.lineTo(1.5, 0.2);
            wingShape.lineTo(1.5, -0.2);
            wingShape.lineTo(0, -0.4);
            wingShape.lineTo(0, 0);
            
            const wingGeometry = new THREE.ExtrudeGeometry(wingShape, { depth: 0.2, bevelEnabled: false });
            
            const leftWing = new THREE.Mesh(wingGeometry, lightGray);
            leftWing.position.set(-1.0, 0, 0);
            leftWing.rotation.y = Math.PI; // Inverser pour l'aile gauche
            playerGroup.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeometry, lightGray);
            rightWing.position.set(1.0, 0, 0);
            playerGroup.add(rightWing);
            
            // Canons latéraux
            const canonGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
            const canonMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.9, roughness: 0.3 });
            
            const leftCanon = new THREE.Mesh(canonGeometry, canonMaterial);
            leftCanon.position.set(-0.8, 0.5, 0);
            leftCanon.rotation.x = Math.PI / 2;
            playerGroup.add(leftCanon);

            const rightCanon = new THREE.Mesh(canonGeometry, canonMaterial);
            rightCanon.position.set(0.8, 0.5, 0);
            rightCanon.rotation.x = Math.PI / 2;
            playerGroup.add(rightCanon);

            // Réacteurs arrière (effets lumineux)
            const jetGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.4, 8);
            const jet = new THREE.Mesh(jetGeometry, brightBlue);
            jet.position.set(0, -0.7, 0);
            jet.rotation.x = Math.PI / 2;
            playerGroup.add(jet);
            
            playerGroup.scale.set(1.2, 1.2, 1.2); // Agrandir légèrement le vaisseau
            playerGroup.position.y = -gameSize.height / 2 + 2;
            
            const audioNode = audioEngine.createSpatialNode();
            
            // AJOUT: Bouclier personnel (CDC 6.4)
            const shieldGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const shieldMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.3,
                wireframe: true 
            });
            const playerShieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            playerShieldMesh.visible = false; // Caché par défaut
            playerGroup.add(playerShieldMesh);

            player = {
                mesh: playerGroup, 
                active: true,
                type: 'player',
                collider: new THREE.Box3(),
                audioNode: audioNode,
                fireCooldown: 0,
                baseFireRate: 0.2,
                fireRate: 0.2,
                powerUpState: 'none',
                powerUpTimer: 0,
                // AJOUT : Variables pour l'animation du vaisseau
                targetRotationY: 0,
                targetRotationX: 0,
                currentRotationY: 0,
                currentRotationX: 0,
                shield: { // AJOUT: Gestion du bouclier (CDC 6.4)
                    active: false,
                    mesh: playerShieldMesh
                }
            };
            scene.add(player.mesh);
            entities.push(player);
        }

        function createAlien(x, y) {
            // AJOUT : Alien renforcé (Nouveau type)
            const isTough = Math.random() < alienGrid.toughAlienChance;
            const alienHealth = isTough ? 2 : 1;
            const alienMaterial = isTough ? alienMatTough : alienMatNormal;
            
            const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const mesh = new THREE.Mesh(geometry, alienMaterial.clone());
            mesh.position.set(x, y, 0);
            
            const audioNode = audioEngine.createSpatialNode();
            // mesh.add(audioNode); // Erreur: Un PannerNode (Web Audio) n'est pas un ObjectD (Three.js)

            const alien = {
                mesh: mesh,
                active: true,
                type: 'alien',
                collider: new THREE.Box3(),
                audioNode: audioNode,
                health: alienHealth,
                baseMaterial: alienMaterial // Sauvegarde le matériau de base
            };
            scene.add(mesh);
            entities.push(alien);
            alienGrid.aliens.push(alien);
        }

        // AJOUT: Création du Boss (CDC 6.3)
        function createBoss() {
            // Nettoie les aliens restants (si jamais)
            alienGrid.aliens.forEach(a => {
                if (a.mesh) scene.remove(a.mesh);
                a.active = false;
            });
            alienGrid.aliens = [];
            
            const bossGeometry = new THREE.BoxGeometry(6, 2, 2);
            const bossMaterial = new THREE.MeshLambertMaterial({ color: 0x880000 }); // Rouge sombre
            const mesh = new THREE.Mesh(bossGeometry, bossMaterial);
            
            mesh.position.set(0, gameSize.height / 2 + 5, 0); // Commence hors écran (en haut)
            
            const audioNode = audioEngine.createSpatialNode();
            
            boss = {
                mesh: mesh,
                active: true,
                type: 'boss',
                collider: new THREE.Box3(),
                audioNode: audioNode,
                maxHealth: 50 + (currentLevel * 10), // Difficulté progressive
                health: 50 + (currentLevel * 10),
                baseMaterial: bossMaterial,
                // FSM du Boss (CDC 6.1)
                fsm: {
                    state: 'ENTERING', // ENTERING, ATTACKING, VULNERABLE
                    timer: 3.0, // Durée de l'état
                    targetY: gameSize.height / 2 - 4 // Position de combat
                },
                fireCooldown: 0.1
            };
            scene.add(mesh);
            entities.push(boss);
            
            // Affiche la barre de vie
            bossHealthBar.style.display = 'block';
            updateHUD();
        }

        // Ajout : Boucliers (CDC 6.5)
        function createShields() {
            const shieldGeometry = new THREE.BoxGeometry(2.5, 0.8, 1);
            const positions = [-6, -2, 2, 6]; // Positions X
            
            for (const x of positions) {
                const mesh = new THREE.Mesh(shieldGeometry, shieldMaterial.clone());
                mesh.position.set(x, -gameSize.height / 2 + 5, 0);
                
                const shield = {
                    mesh: mesh,
                    active: true,
                    type: 'shield',
                    collider: new THREE.Box3(),
                    health: 10 // 10 coups pour détruire
                };
                scene.add(mesh);
                shields.push(shield);
                entities.push(shield);
            }
        }
        
        // Ajout : Vaisseau Mystère (UFO) (CDC 5.3)
        function createUFO() {
            if (ufo) return; // Un seul UFO à la fois

            const mesh = new THREE.Mesh(ufoGeometry, ufoMaterial);
            mesh.position.set(-gameSize.width / 2 - 2, gameSize.height / 2 - 1, 0); // Apparaît à gauche
            
            ufo = {
                mesh: mesh,
                active: true,
                type: 'ufo',
                collider: new THREE.Box3(),
                velocity: new THREE.Vector3(3, 0, 0), // Se déplace vers la droite
                health: 1
            };
            scene.add(mesh);
            entities.push(ufo);
        }

        function createAlienGrid() {
            // AJOUT: Difficulté progressive (CDC Niveaux)
            // Augmente la vitesse, la cadence de tir et la chance d'avoir des ennemis "tough"
            alienGrid.speed = alienGrid.baseSpeed + (currentLevel * 0.05);
            alienGrid.fireRate = Math.min(0.1, alienGrid.baseFireRate + (currentLevel * 0.002));
            alienGrid.toughAlienChance = Math.min(0.6, 0.2 + (currentLevel * 0.02));

            const rows = Math.min(5, 3 + Math.floor(currentLevel / 3)); // Ajoute des rangées
            const cols = 8;
            const startX = - (cols / 2) * 1.5 + 0.75;
            const startY = gameSize.height / 2 - 3;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    createAlien(startX + c * 1.5, startY - r * 1.5);
                }
            }
        }
        
        // AJOUT (CDC 4.3) : Arrière-plan "Starfield"
        function createStarfield() {
            const starCount = 5000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                positions[i * 3    ] = (Math.random() - 0.5) * 100; // x
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100; // y
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100; // z
            }
            
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }
        
        // --- 4.4 "Juiciness" : Screenshake (CDC Section 7.1) ---
        let shake = { intensity: 0, duration: 0 };
        function triggerScreenshake(intensity, duration) {
            shake.intensity = intensity;
            shake.duration = duration;
        }

        // --- 4.5 "Juiciness" : Particules (CDC Section 7.3) ---
        function createExplosion(position, count, color) {
            for (let i = 0; i < count; i++) {
                const p = particlePool.get();
                p.mesh.position.copy(position);
                p.mesh.material.color.set(color);
            }
        }

        // =====================================================================
        // 5. SYSTÈMES (Logique de la boucle de jeu) (CDC Section 3.3)
        // =====================================================================

        // --- 5.1 PlayerSystem / InputSystem ---
        function updatePlayer(dt) {
            if (!player || !player.active) return;

            const speed = 7;
            let currentMoveX = 0;

            if (input.left) {
                player.mesh.position.x -= speed * dt;
                currentMoveX = -1;
            }
            if (input.right) {
                player.mesh.position.x += speed * dt;
                currentMoveX = 1;
            }
            input.currentMoveX = currentMoveX; // Met à jour la direction de mouvement

            // Contraintes de l'écran
            const halfWidth = gameSize.width / 2;
            player.mesh.position.x = Math.max(-halfWidth, Math.min(halfWidth, player.mesh.position.x));

            // Mise à jour de la spatialisation audio (Section 8.2)
            if (player.audioNode && audioContext) {
                player.audioNode.positionX.setValueAtTime(player.mesh.position.x, audioContext.currentTime);
                player.audioNode.positionY.setValueAtTime(player.mesh.position.y, audioContext.currentTime);
                player.audioNode.positionZ.setValueAtTime(player.mesh.position.z, audioContext.currentTime);
            }

            // AJOUT : Gestion du timer de Power-up (CDC 6.4)
            if (player.powerUpTimer > 0) {
                player.powerUpTimer -= dt;
                if (player.powerUpTimer <= 0) {
                    // Fin du power-up
                    player.powerUpState = 'none';
                    player.fireRate = player.baseFireRate;
                }
            }

            // AJOUT: Gestion du bouclier (CDC 6.4)
            player.shield.mesh.visible = player.shield.active;
            if(player.shield.active) {
                player.shield.mesh.rotation.y += dt * 0.5;
            }

            // Système de tir (FireRateComponent)
            player.fireCooldown -= dt;
            if (input.fire && player.fireCooldown <= 0) {
                player.fireCooldown = player.fireRate;
                
                // MODIFIÉ : Logique de tir (CDC 6.4)
                switch (player.powerUpState) {
                    case 'spread_shot':
                        // Tir en éventail
                        spawnPlayerBullet(0, 15, 0); // Centre
                        spawnPlayerBullet(-5, 14, 0); // Gauche
                        spawnPlayerBullet(5, 14, 0);  // Droite
                        break;
                    
                    case 'rapid_fire':
                    case 'none':
                    default:
                        // Tir normal
                        spawnPlayerBullet(0, 15, 0);
                        break;
                }
                
                // Audio (Section 8.2)
                audioEngine.playSound('shoot', player.audioNode);
            }
        }

        // AJOUT : Fonction utilitaire pour le tir
        function spawnPlayerBullet(velX, velY, velZ) {
            const bullet = bulletPool.get();
            bullet.isPlayerBullet = true;
            bullet.mesh.material = playerBulletMaterial;
            bullet.mesh.position.copy(player.mesh.position).y += 0.5;
            bullet.velocity.set(velX, velY, velZ); // Vitesse des tirs joueur
        }

        // --- 5.2 AlienAISystem (CDC Section 6.1 / 5.2) ---
        function updateAliens(dt) {
            // MODIFIÉ: L'IA des aliens ne tourne pas si un boss est actif
            if (alienGrid.aliens.length === 0 || boss) return;

            let hitEdge = false;
            const halfWidth = gameSize.width / 2;

            for (const alien of alienGrid.aliens) {
                if (!alien.active) continue;
                
                let moveY = 0;
                if (alienGrid.moveDown) {
                    moveY = -1.0; // Descend d'une rangée
                }
                alien.mesh.position.x += alienGrid.direction * alienGrid.speed * dt;
                alien.mesh.position.y += moveY;
                
                // Mise à jour de la spatialisation audio (Section 8.2)
                if (alien.audioNode && audioContext) {
                    alien.audioNode.positionX.setValueAtTime(alien.mesh.position.x, audioContext.currentTime);
                    alien.audioNode.positionY.setValueAtTime(alien.mesh.position.y, audioContext.currentTime);
                    alien.audioNode.positionZ.setValueAtTime(alien.mesh.position.z, audioContext.currentTime);
                }
                
                if (alien.mesh.position.x > halfWidth || alien.mesh.position.x < -halfWidth) {
                    hitEdge = true;
                }
                
                // Logique de tir (Section 5.2)
                if (Math.random() < alienGrid.fireRate * dt) {
                     const bullet = bulletPool.get();
                     bullet.isPlayerBullet = false;
                     bullet.mesh.material = alienBulletMaterial;
                     bullet.mesh.position.copy(alien.mesh.position).y -= 0.5;
                     bullet.velocity.set(0, -5, 0); // Vitesse des tirs aliens
                     // Pas de son pour les tirs aliens pour l'instant
                }
                
                // Vérifie défaite
                if (alien.mesh.position.y < player.mesh.position.y) {
                    setGameState(GAME_STATE.GAME_OVER);
                }
            }

            if (alienGrid.moveDown) {
                alienGrid.moveDown = false;
            }
            
            if (hitEdge) {
                alienGrid.direction *= -1; // Change de direction
                alienGrid.moveDown = true;
                alienGrid.speed *= 1.05; // Accélère (Section 5.2)
            }
        }
        
        // AJOUT: IA du Boss (CDC 6.3 / 6.1)
        function updateBoss(dt) {
            if (!boss || !boss.active) return;
            
            const state = boss.fsm.state;
            boss.fsm.timer -= dt;
            
            // FSM (Machine à états)
            switch(state) {
                case 'ENTERING':
                    // Phase 1: Le boss descend à sa position de combat
                    boss.mesh.position.y = THREE.MathUtils.lerp(boss.mesh.position.y, boss.fsm.targetY, 0.05);
                    if (boss.fsm.timer <= 0) {
                        boss.fsm.state = 'ATTACKING';
                        boss.fsm.timer = 5.0; // 5 secondes d'attaque
                    }
                    break;
                    
                case 'ATTACKING':
                    // Phase 2: Le boss tire rapidement
                    boss.mesh.material.color.set(0xff0000); // Rouge vif (attaque)
                    boss.fireCooldown -= dt;
                    if (boss.fireCooldown <= 0) {
                        // Tir en éventail
                        const positions = [-2, 0, 2];
                        for (const xOffset of positions) {
                            const bullet = bulletPool.get();
                            bullet.isPlayerBullet = false;
                            bullet.mesh.material = alienBulletMaterial;
                            bullet.mesh.position.copy(boss.mesh.position).y -= 1.0;
                            bullet.mesh.position.x += xOffset;
                            bullet.velocity.set(0, -8, 0); // Tirs plus rapides
                        }
                        boss.fireCooldown = 0.3; // Cadence de tir du boss
                    }
                    
                    if (boss.fsm.timer <= 0) {
                        boss.fsm.state = 'VULNERABLE';
                        boss.fsm.timer = 3.0; // 3 secondes de pause
                    }
                    break;
                    
                case 'VULNERABLE':
                    // Phase 3: Le boss fait une pause (c'est le moment de tirer !)
                    boss.mesh.material = boss.baseMaterial; // Couleur normale
                    
                    if (boss.fsm.timer <= 0) {
                        boss.fsm.state = 'ATTACKING';
                        boss.fsm.timer = 5.0; // Retour à l'attaque
                    }
                    break;
            }
            
            // Mouvement latéral simple
            boss.mesh.position.x = Math.sin(clock.getElapsedTime() * 0.5) * (gameSize.width / 2 - 3);
        }

        // Ajout : Logique UFO (CDC 5.3)
        function updateUFO(dt) {
            ufoSpawnTimer -= dt;
            if (ufoSpawnTimer <= 0 && !ufo) {
                createUFO();
                ufoSpawnTimer = 15.0 + Math.random() * 10; // Prochain UFO dans 15-25s
            }
            
            if (ufo && ufo.active) {
                ufo.mesh.position.x += ufo.velocity.x * dt;
                ufo.mesh.rotation.y += dt * 2;
                
                // Détruire si sort de l'écran
                if (ufo.mesh.position.x > gameSize.width / 2 + 2) {
                    scene.remove(ufo.mesh);
                    ufo = null;
                }
            }
        }
        
        // --- 5.3 MovementSystem / TimerSystem (CDC Section 3.3) ---
        function updateMovementAndLifetime(dt) {
            // Concerne les projectiles, les particules et les power-ups
            const activeBullets = bulletPool.getActiveObjects();
            const activeParticles = particlePool.getActiveObjects();
            const activePowerUps = powerUpPool.getActiveObjects();
            
            for (const entity of [...activeBullets, ...activeParticles, ...activePowerUps]) {
                // MovementSystem
                entity.mesh.position.x += entity.velocity.x * dt;
                entity.mesh.position.y += entity.velocity.y * dt;
                entity.mesh.position.z += entity.velocity.z * dt;

                // Mise à jour de la spatialisation audio (Section 8.2)
                if (entity.audioNode && audioContext) {
                    entity.audioNode.positionX.setValueAtTime(entity.mesh.position.x, audioContext.currentTime);
                    entity.audioNode.positionY.setValueAtTime(entity.mesh.position.y, audioContext.currentTime);
                    entity.audioNode.positionZ.setValueAtTime(entity.mesh.position.z, audioContext.currentTime);
                }

                // TimerSystem (LifetimeComponent)
                entity.lifetime -= dt;
                if (entity.lifetime <= 0) {
                    if (entity.type === 'bullet') bulletPool.release(entity);
                    if (entity.type === 'particle') particlePool.release(entity);
                    if (entity.type === 'powerup') powerUpPool.release(entity);
                }
                
                // Particle-specific (Render logic)
                if (entity.type === 'particle') {
                    entity.mesh.material.opacity = entity.lifetime * 2; // Fade out
                }
            }
        }

        // --- 5.4 CollisionSystem (CDC Section 4.2) ---
        // Utilise BoundingBox (Box3) au lieu de Quadtree pour ce prototype 3D
        function updateCollisions() {
            const activeBullets = bulletPool.getActiveObjects();
            const activePowerUps = powerUpPool.getActiveObjects();
            
            // Met à jour les BoundingBox
            // Note: le joueur est mis à jour séparément
            player.collider.setFromObject(player.mesh);
            
            for (const entity of [...alienGrid.aliens, ...activeBullets, ...shields, ...activePowerUps]) {
                if (!entity || !entity.active) continue;
                entity.collider.setFromObject(entity.mesh);
            }
            if (ufo && ufo.active) {
                ufo.collider.setFromObject(ufo.mesh);
            }
            // AJOUT: Collider du Boss
            if (boss && boss.active) {
                boss.collider.setFromObject(boss.mesh);
            }

            // 1. Tirs Joueur vs ...
            for (const bullet of activeBullets) {
                if (!bullet.isPlayerBullet || !bullet.active) continue;

                // ... vs Aliens
                for (const alien of alienGrid.aliens) {
                    if (!alien.active) continue;
                    
                    if (bullet.collider.intersectsBox(alien.collider)) {
                        // Collision ! (DamageSystem / DeathSystem)
                        bulletPool.release(bullet);
                        alien.health--;
                        
                        // Feedback d'impact (Section 7.2) - Flash
                        alien.mesh.material.color.set(0xffffff);
                        // MODIFIÉ : Réinitialise au bon matériau
                        setTimeout(() => {
                            if (alien.mesh) alien.mesh.material = alien.baseMaterial;
                        }, 50);

                        if (alien.health <= 0) {
                            // DeathSystem
                            alien.active = false;
                            scene.remove(alien.mesh);
                            audioEngine.playSound('explosion', alien.audioNode);
                            triggerScreenshake(0.1, 0.2);
                            createExplosion(alien.mesh.position, 30, 0xff00ff);
                            score += 100;
                            updateHUD();
                            
                            // Ajout : Chance de lâcher un power-up (CDC 6.4)
                            if (Math.random() < alienGrid.dropChance) {
                                spawnPowerUp(alien.mesh.position);
                            }
                        }
                    }
                }
                
                // ... vs Boucliers (CDC 6.5)
                for (const shield of shields) {
                    if (!shield.active) continue;
                    if (bullet.collider.intersectsBox(shield.collider)) {
                        bulletPool.release(bullet);
                        shield.health--;
                        // Feedback visuel : devient plus transparent
                        shield.mesh.material.opacity = shield.health / 10 * 0.8; 
                        if (shield.health <= 0) {
                            shield.active = false;
                            scene.remove(shield.mesh);
                            createExplosion(shield.mesh.position, 20, 0x0088ff);
                        }
                    }
                }
                
                // ... vs UFO (CDC 5.3)
                if (ufo && ufo.active && bullet.collider.intersectsBox(ufo.collider)) {
                    bulletPool.release(bullet);
                    ufo.health--;
                    if (ufo.health <= 0) {
                        ufo.active = false;
                        scene.remove(ufo.mesh);
                        ufo = null;
                        // CORRECTION: Logique de score/effet du UFO (était manquante/corrompue)
                        score += 500; // Bonus
                        updateHUD();
                        triggerScreenshake(0.2, 0.3);
                        createExplosion(bullet.mesh.position, 50, 0xff4444);
                    } // <--- CORRECTION: accolade fermante manquante
                }
                
                // AJOUT: ... vs Boss (CDC 6.3)
                if (boss && boss.active && bullet.collider.intersectsBox(boss.collider)) {
                    bulletPool.release(bullet);
                    boss.health--;
                    updateHUD(); // Met à jour la barre de vie
                    
                    // Feedback (Section 7.2)
                    boss.mesh.material.color.set(0xffffff);
                    setTimeout(() => {
                        if (boss.mesh) {
                            // Revient à la couleur de l'état actuel
                            if(boss.fsm.state === 'ATTACKING') {
                                boss.mesh.material.color.set(0xff0000);
                            } else {
                                boss.mesh.material = boss.baseMaterial;
                            }
                        }
                    }, 50);
                    
                    if (boss.health <= 0) {
                        // Mort du Boss
                        boss.active = false;
                        scene.remove(boss.mesh);
                        boss = null;
                        
                        score += 1000; // Gros bonus
                        triggerScreenshake(0.5, 1.0);
                        createExplosion(bullet.mesh.position, 200, 0xff8800);
                        bossHealthBar.style.display = 'none';
                        
                        // Passe au niveau suivant
                        advanceLevel();
                    }
                }
            }
            
            // 2. Tirs Aliens vs ...
            if (!player.active) return;
            for (const bullet of activeBullets) {
                if (bullet.isPlayerBullet || !bullet.active) continue;
                
                // AJOUT: ... vs Bouclier Personnel (CDC 6.4)
                if (player.shield.active && bullet.collider.intersectsBox(player.collider)) {
                    bulletPool.release(bullet);
                    player.shield.active = false; // Le bouclier casse
                    triggerScreenshake(0.1, 0.2);
                    createExplosion(player.mesh.position, 20, 0x00ffff);
                    continue; // Le tir est absorbé
                }

                // ... vs Joueur
                if (bullet.collider.intersectsBox(player.collider)) {
                    bulletPool.release(bullet);
                    lives--;
                    updateHUD();
                    triggerScreenshake(0.3, 0.5);
                    createExplosion(player.mesh.position, 50, 0x00ffff);
                    audioEngine.playSound('hit', player.audioNode);
                    
                    if (lives <= 0) {
                        // GAME OVER
                        player.active = false;
                        scene.remove(player.mesh);
                        setGameState(GAME_STATE.GAME_OVER);
                    }
                }
                
                // ... vs Boucliers (CDC 6.5)
                for (const shield of shields) {
                    if (!shield.active) continue;
                    if (bullet.collider.intersectsBox(shield.collider)) {
                        bulletPool.release(bullet);
                        shield.health--;
                        shield.mesh.material.opacity = shield.health / 10 * 0.8;
                        if (shield.health <= 0) {
                            shield.active = false;
                            scene.remove(shield.mesh);
                            createExplosion(shield.mesh.position, 20, 0x0088ff);
                        }
                    }
                }
            }
            
            // CORRECTION: Logique de collision "Joueur vs Power-Ups" (était manquante)
            // 3. Joueur vs Power-Ups (CDC 6.4)
            if (player.active) {
                for (const powerUp of activePowerUps) {
                    if (powerUp.active && player.collider.intersectsBox(powerUp.collider)) {
                        powerUpPool.release(powerUp);
                        activatePowerUp(powerUp.powerUpType);
                    }
                }
            }
            
            // CORRECTION: Logique de nettoyage et de passage au niveau suivant (était manquante)
            // Nettoie la liste des aliens
            alienGrid.aliens = alienGrid.aliens.filter(a => a.active);
            // MODIFIÉ: Ne passe au niveau suivant que s'il n'y a ni aliens NI boss
            if (alienGrid.aliens.length === 0 && !boss && currentGameState === GAME_STATE.PLAYING) {
                // S'il n'y a plus d'aliens, passe au niveau suivant
                advanceLevel();
            }
        }
        
        // AJOUT: Système de gestion de niveaux
        function advanceLevel() {
            currentLevel++;
            
            // Logique de "Looping" (CDC Nv. 15+)
            if (currentLevel > 15) {
                currentLevel = 1; // Reprend au niveau 1
                // Note: Le score n'est PAS réinitialisé.
            }

            // Logique de Boss (CDC Boss)
            // C'est ici que nous ajouterons le boss
            if (currentLevel % 3 === 0) {
                // *** MODIFIÉ: On lance le BOSS ***
                console.log(`NIVEAU ${currentLevel}: BOSS ENTRANT !`);
                createBoss(); 
            } else {
                console.log(`NIVEAU ${currentLevel}: Vague d'aliens`);
                createAlienGrid();
            }

            updateHUD(); // Met à jour l'affichage du niveau
        }
        
        // Ajout : Logique Power-Up (CDC 6.4)
        function spawnPowerUp(position) {
            const p = powerUpPool.get();
            p.mesh.position.copy(position);
            // La randomisation du type est maintenant dans resetPowerUp()
        }
        
        function activatePowerUp(type) {
            player.powerUpState = type;
            player.powerUpTimer = 5.0; // Dure 5 secondes
            
            if (type === 'rapid_fire') {
                player.fireRate = player.baseFireRate / 2; // Tire 2x plus vite
            } else if (type === 'spread_shot') {
                player.fireRate = player.baseFireRate; // Garde la cadence normale
            } else if (type === 'shield') {
                // AJOUT: Activation du bouclier (CDC 6.4)
                player.shield.active = true;
            }
        }
        
        // --- 5.5 RenderSystem (CDC Section 3.3 / 7.1) ---
        function updateRender(dt) {
            // Gestion du Screenshake (Section 7.1)
            if (shake.duration > 0) {
                shake.duration -= dt;
                const s = shake.intensity;
                camera.position.x = Math.random() * s - s / 2;
                camera.position.z = 10 + Math.random() * s - s / 2;
                camera.rotation.z = Math.random() * (s/5) - (s/10);
            } else {
                camera.position.x = 0;
                camera.position.z = 10;
                camera.rotation.z = 0;
            }
            
            // AJOUT (CDC 10.1) : Animation subtile du vaisseau joueur
            if (player && player.active) {
                // Rotation de lacet (Y) en fonction du mouvement horizontal
                player.targetRotationY = -input.currentMoveX * 0.1; // Petite inclinaison latérale
                player.currentRotationY = THREE.MathUtils.lerp(player.currentRotationY, player.targetRotationY, 0.1);
                player.mesh.rotation.y = player.currentRotationY;

                // Rotation de tangage (X) subtile
                player.targetRotationX = Math.sin(clock.getElapsedTime() * 2) * 0.05; // Oscillation douce
                player.currentRotationX = THREE.MathUtils.lerp(player.currentRotationX, player.targetRotationX, 0.05);
                player.mesh.rotation.x = player.currentRotationX + Math.PI / 2; // +PI/2 pour orienter vers le haut
            }

            // AJOUT (CDC 4.3) : Mouvement du Starfield
            if (starfield) {
                starfield.position.y += dt * 0.2; // Défilement lent
                if (starfield.position.y > 50) {
                    starfield.position.y = -50;
                }
            }
            
            // Rotation des aliens (pour le "look" 3D)
            for (const alien of alienGrid.aliens) {
                if (alien.active && alien.mesh) {
                    alien.mesh.rotation.x += dt;
                    alien.mesh.rotation.y += dt;
                }
            }

            renderer.render(scene, camera);
        }

        // =====================================================================
        // 6. GESTION DES ÉTATS ET INITIALISATION
        // =====================================================================

        // --- 6.1 Initialisation (Setup) ---
        async function init() {
            // 1. UI (Montre le chargement)
            document.getElementById('loading-screen').style.display = 'flex';
            // AJOUT: Récupère les éléments de la barre de vie du boss
            bossHealthBar = document.getElementById('boss-health-bar');
            bossHealthElement = document.getElementById('boss-health');
            
            // MODIFIÉ: Le high score est chargé dans setGameState
            
            // 2. Moteur Audio (Section 8)
            await audioEngine.init();
            
            // 3. Moteur de Rendu (Three.js)
            scene = new THREE.Scene();
            
            // AJOUT: Couleur de fond (espace)
            scene.background = new THREE.Color(0x050510); 
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10; // Recule la caméra
            
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // AJOUT: Active les ombres (pour les MeshStandardMaterial)
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            clock = new THREE.Clock();

            // Lumières
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            // AJOUT: Directional Light avec ombres
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true; // La lumière projette des ombres
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            // Ajuste la zone d'ombre pour notre scène
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);
            
            // 4. Pré-chargement (Section 9.4)
            // Simule la création de sons. Dans un vrai jeu, ce seraient des .mp3/.wav
            // Pour éviter des requêtes externes, je génère des sons simples.
            // ... (Omis pour la simplicité, on charge juste des placeholders)
            // Note: Le chargement réel des sons est asynchrone.
            // On prétend charger les sons ici.
            document.getElementById('loading-text').innerText = 'CHARGEMENT TERMINÉ.';
            
            // AJOUT (CDC 4.3) : Crée l'arrière-plan
            createStarfield();
            
            // 5. Initialisation des Pools (Section 4.1)
            bulletPool = new ObjectPool(createBulletEntity, resetBullet, 100);
            particlePool = new ObjectPool(createParticleEntity, resetParticle, 200);
            powerUpPool = new ObjectPool(createPowerUpEntity, resetPowerUp, 20); // Pool pour les power-ups

            // 6. Gestionnaires d'événements
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            document.getElementById('start-button').addEventListener('click', () => {
                setGameState(GAME_STATE.PLAYING);
            });
            document.getElementById('restart-button').addEventListener('click', () => {
                resetGame();
                setGameState(GAME_STATE.PLAYING);
            });
            // AJOUT: Bouton Reprendre (CDC 9.2)
            document.getElementById('resume-button').addEventListener('click', () => {
                setGameState(GAME_STATE.PLAYING);
            });

            // 7. Démarrer la FSM
            setGameState(GAME_STATE.MAIN_MENU);
            
            // 8. Démarrer la boucle de jeu (Section 2.2)
            renderer.setAnimationLoop(gameLoop);
        }

        // --- 6.2 Changement d'état (FSM) (Section 9.2) ---
        function setGameState(newState) {
            if (currentGameState === newState) return;

            // AJOUT: Logique de bascule pour la Pause (CDC 9.2)
            // Gère la pause sans cacher le HUD
            if (newState === GAME_STATE.PLAYING && currentGameState === GAME_STATE.PAUSED) {
                // On reprend le jeu
                document.getElementById('pause-menu').style.display = 'none';
                currentGameState = newState;
                return; // On sort pour ne pas cacher le HUD
            }
            if (newState === GAME_STATE.PAUSED && currentGameState === GAME_STATE.PLAYING) {
                // On met en pause
                document.getElementById('pause-menu').style.display = 'flex';
                currentGameState = newState;
                return; // On sort pour garder le HUD visible
            }

            currentGameState = newState;

            // Cache tous les écrans (pour les transitions complètes)
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('pause-menu').style.display = 'none'; // AJOUT

            // Active l'état demandé
            switch (newState) {
                case GAME_STATE.PRELOADING:
                    document.getElementById('loading-screen').style.display = 'flex';
                    break;
                case GAME_STATE.MAIN_MENU:
                    document.getElementById('main-menu').style.display = 'flex';
                    // MODIFIÉ: Charger le panneau des scores (CDC 9.6)
                    loadLeaderboard();
                    break;
                case GAME_STATE.PLAYING:
                    // Démarrage du jeu
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    resetGame(); // Réinitialise si c'est un nouveau jeu
                    document.getElementById('hud').style.display = 'flex';
                    break;
                case GAME_STATE.GAME_OVER:
                    document.getElementById('final-score').innerText = `SCORE : ${score}`;
                    document.getElementById('game-over-screen').style.display = 'flex';
                    // MODIFIÉ: Sauvegarder au panneau des scores (CDC 9.6)
                    saveScoreToLeaderboard();
                    bossHealthBar.style.display = 'none'; // Cache la barre de vie
                    break;
            }
        }
        
        // AJOUT: Panneau des scores (CDC 9.6)
        function loadLeaderboard() {
            const scores = JSON.parse(localStorage.getItem('eliteInvaders_leaderboard')) || [];
            const list = document.getElementById('high-score-list');
            list.innerHTML = ''; // Vide la liste
            
            if (scores.length === 0) {
                list.innerHTML = '<li>AUCUN SCORE</li>';
                return;
            }
            
            // Prend les 5 meilleurs (ou moins)
            const topScores = scores.slice(0, 5); 
            
            for (const s of topScores) {
                const li = document.createElement('li');
                li.textContent = s;
                list.appendChild(li);
            }
        }

        // AJOUT: Panneau des scores (CDC 9.6)
        function saveScoreToLeaderboard() {
            const scores = JSON.parse(localStorage.getItem('eliteInvaders_leaderboard')) || [];
            scores.push(score);
            scores.sort((a, b) => b - a); // Tri descendant
            
            const topScores = scores.slice(0, 5); // Garde le top 5
            
            localStorage.setItem('eliteInvaders_leaderboard', JSON.stringify(topScores));
        }

        // --- 6.3 Réinitialisation du jeu ---
        function resetGame() {
            // Nettoie les entités
            entities.forEach(e => {
                if (e.mesh) scene.remove(e.mesh);
            });
            entities = [];
            alienGrid.aliens = [];
            shields = []; // Vide le tableau des boucliers
            
            // Réinitialise les pools
            bulletPool.getActiveObjects().forEach(b => bulletPool.release(b));
            particlePool.getActiveObjects().forEach(p => particlePool.release(p));
            powerUpPool.getActiveObjects().forEach(p => powerUpPool.release(p));
            
            // Réinitialise l'UFO
            if (ufo) {
                scene.remove(ufo.mesh);
                ufo = null;
            }
            ufoSpawnTimer = 15.0;
            
            // AJOUT: Réinitialise le Boss
            if (boss) {
                scene.remove(boss.mesh);
                boss = null;
            }
            bossHealthBar.style.display = 'none';
            
            // Recrée le joueur, les aliens et les boucliers
            createPlayer();
            createAlienGrid();
            createShields();
            
            // AJOUT : Nettoie et recrée le starfield
            if (starfield) {
                scene.remove(starfield);
            }
            createStarfield();
            
            // Réinitialise les stats
            score = 0;
            lives = 3;
            currentLevel = 1; // AJOUT: Réinitialise le niveau
            alienGrid.speed = alienGrid.baseSpeed; // MODIFIÉ
            alienGrid.direction = 1;
            updateHUD();
        }

        // --- 6.4 Boucle de Jeu Principale ---
        function gameLoop() {
            deltaTime = clock.getDelta();

            // La FSM (Section 9.2) contrôle ce qui est mis à jour
            if (currentGameState === GAME_STATE.PLAYING) {
                // Logique de jeu (ECS Systems)
                updatePlayer(deltaTime);
                // MODIFIÉ: updateAliens et updateBoss s'excluent mutuellement
                if (boss) {
                    updateBoss(deltaTime);
                } else {
                    updateAliens(deltaTime);
                }
                updateUFO(deltaTime); // Ajout du système UFO
                updateMovementAndLifetime(deltaTime);
                updateCollisions();
            }
            
            // Le rendu et les effets tournent toujours (sauf en PRELOADING)
            if (currentGameState !== GAME_STATE.PRELOADING) {
                updateRender(deltaTime);
            }
        }

        // --- 6.5 Gestionnaires d'événements (Input) ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    input.left = true;
                    break;
                // --- CORRECTION APPLIQUÉE ICI ---
                case 'ArrowRight':
                case 'KeyD': // Ajout de la touche D
                    input.right = true; // Ajout de la logique pour aller à droite
                    break; // Ajout du break manquant
                case 'Space': // Ajout pour cohérence
                case 'ArrowUp': // Ajout pour cohérence
                case 'KeyW':
                    input.fire = true;
                    break;
                // AJOUT: Gestion de la Pause (CDC 9.2)
                case 'Escape':
                    if (currentGameState === GAME_STATE.PLAYING) {
                        setGameState(GAME_STATE.PAUSED);
                    } else if (currentGameState === GAME_STATE.PAUSED) {
                        setGameState(GAME_STATE.PLAYING);
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    input.left = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    input.right = false;
                    break;
                case 'Space':
                case 'ArrowUp':
                case 'KeyW':
                    input.fire = false;
                    break;
            }
        }
        
        // --- 6.6 UI (HUD) ---
        function updateHUD() {
            document.getElementById('score').innerText = `SCORE : ${score}`;
            document.getElementById('lives').innerText = `VIES : ${lives}`;
            document.getElementById('level').innerText = `NIVEAU : ${currentLevel}`; // AJOUT
            
            // AJOUT: Mise à jour de la barre de vie du boss (CDC 9.3)
            if (boss && boss.active) {
                const healthPercent = (boss.health / boss.maxHealth) * 100;
                bossHealthElement.style.width = `${healthPercent}%`;
            }
        }

        // --- Démarrage ---
        init();

    </script>
</body>
</html>
